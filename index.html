<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Assistente ConcordatoFacile</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='10 0 100 100'><text y='.9em' font-size='90'>ü§ñ</text></svg>">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Material Design Fonts and Icons -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
    <style>
        :root {
          /* Material Design Color Palette ( –ø—Ä–∏–º–µ—Ä ) */
          --md-sys-color-primary: #6750A4; /* Purple */
          --md-sys-color-on-primary: #FFFFFF;
          --md-sys-color-primary-container: #EADDFF;
          --md-sys-color-on-primary-container: #21005D;
          --md-sys-color-secondary: #625B71; /* Neutral */
          --md-sys-color-on-secondary: #FFFFFF;
          --md-sys-color-secondary-container: #E8DEF8;
          --md-sys-color-on-secondary-container: #1D192B;
          --md-sys-color-tertiary: #7D5260; /* Pink/Red */
          --md-sys-color-on-tertiary: #FFFFFF;
          --md-sys-color-tertiary-container: #FFD8E4;
          --md-sys-color-on-tertiary-container: #31111D;
          --md-sys-color-error: #B3261E;
          --md-sys-color-on-error: #FFFFFF;
          --md-sys-color-error-container: #F9DEDC;
          --md-sys-color-on-error-container: #410E0B;
          --md-sys-color-background: #FFFBFE; /* Light background */
          --md-sys-color-on-background: #1C1B1F;
          --md-sys-color-surface: #FFFBFE; /* Cards, dialogs */
          --md-sys-color-on-surface: #1C1B1F;
          --md-sys-color-surface-variant: #E7E0EC; /* Text fields, chip backgrounds */
          --md-sys-color-on-surface-variant: #49454F;
          --md-sys-color-outline: #79747E; /* Borders */
          --md-sys-color-shadow: #000000;

          /* Custom variables mapping to Material for easier transition */
          --bg-color: var(--md-sys-color-background);
          --text-color: var(--md-sys-color-on-surface);
          --input-bg-color: var(--md-sys-color-surface-variant); /* For input area background */
          --input-field-bg: var(--md-sys-color-surface); /* For textarea itself */
          --border-color: var(--md-sys-color-outline);

          --prompt-color: var(--md-sys-color-primary);
          --user-prefix-color: var(--md-sys-color-primary);
          --assistant-color: var(--md-sys-color-secondary); /* Adjusted from purple to neutral */
          --system-color: var(--md-sys-color-on-surface-variant);
          --command-color: var(--md-sys-color-tertiary);
          --error-color: var(--md-sys-color-error);
          --highlight-color: var(--md-sys-color-primary);
          --scrollbar-thumb-color: #BDBDBD; /* Material-like scrollbar */
          --scrollbar-track-color: #F0F0F0;

          --font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
          --font-size-base: 16px; /* Material default is often 16px for body, 14px for smaller text */
          --font-size-mobile: 15px;
          --line-height: 1.6;

          --padding-base: 16px; /* Material uses 8dp grid, so multiples of 8 */
          --padding-mobile: 12px;
          --border-radius-base: 8px; /* Slightly more rounded than default 4px for a softer look */
          --border-radius-material: 4px; /* Standard Material radius */
          --elevation-1: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06);
          --elevation-2: 0 3px 6px 0 rgba(0,0,0,0.1), 0 3px 4px 0 rgba(0,0,0,0.06);
        }

        *, *::before, *::after {
          box-sizing: border-box;
        }

        html {
          font-size: var(--font-size-base);
        }

        body {
          background-color: var(--bg-color);
          color: var(--text-color);
          font-family: var(--font-family);
          margin: 0;
          padding: 0;
          display: flex;
          flex-direction: column;
          height: 100vh;
          height: 100dvh; /* Use dvh for mobile viewport consistency */
          overflow: hidden;
        }

        main#terminal {
          flex-grow: 1;
          padding: var(--padding-base) var(--padding-base) 0px var(--padding-base);
          overflow-y: auto;
          white-space: pre-wrap;
          word-wrap: break-word;
          line-height: var(--line-height);
        }

        main#terminal::-webkit-scrollbar { width: 8px; }
        main#terminal::-webkit-scrollbar-track { background: var(--scrollbar-track-color); }
        main#terminal::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb-color); border-radius: 4px; }
        main#terminal::-webkit-scrollbar-thumb:hover { background-color: #9E9E9E; }
        main#terminal { scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb-color) var(--scrollbar-track-color); }

        footer#inputArea {
          display: flex;
          flex-direction: column;
          align-items: stretch;
          background-color: var(--md-sys-color-surface-variant); /* Lightly different background */
          padding: calc(var(--padding-base) / 2) var(--padding-base);
          border-top: 1px solid var(--md-sys-color-outline);
          box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.08);
          flex-shrink: 0;
          position: relative;
          z-index: 10;
        }

        /* Action Buttons Container */
        #actionButtonsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
            padding: 4px 0;
        }

        .action-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background-color: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
            border: none;
            border-radius: var(--border-radius-material);
            font-family: var(--font-family);
            font-size: 0.875em; /* 14px */
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        .action-btn:hover {
            background-color: var(--md-sys-color-secondary);
            color: var(--md-sys-color-on-secondary);
        }
        .action-btn:active {
            background-color: var(--md-sys-color-secondary);
            color: var(--md-sys-color-on-secondary);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }
        .action-btn .material-symbols-outlined {
            font-size: 1.2em; /* Make icon slightly larger than text */
        }
        #stopAiBtn {
            background-color: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
        }
        #stopAiBtn:hover {
            background-color: var(--md-sys-color-error);
            color: var(--md-sys-color-on-error);
        }


        #fileListContainer {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            font-size: 0.875em; /* 14px */
            color: var(--md-sys-color-on-surface-variant);
            background-color: var(--md-sys-color-surface);
            border-radius: var(--border-radius-material);
            display: none; /* Initially hidden */
            box-shadow: var(--elevation-1);
        }
        #fileListContainer strong {
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
        }
        #fileListDisplay {
            margin-left: 5px;
            max-height: 45px;
            overflow-y: auto;
            display: inline-block;
            vertical-align: middle;
            color: var(--md-sys-color-on-surface-variant);
        }
        /* Clear Files Button - styled as an icon button */
        #clearFilesBtn {
            float: right;
            background: none;
            border: none;
            color: var(--md-sys-color-error);
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            display: inline-flex; /* Initially hidden in JS */
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
        }
        #clearFilesBtn:hover {
            background-color: var(--md-sys-color-error-container);
        }
        #clearFilesBtn .material-symbols-outlined {
            font-size: 20px;
        }


        #inputControls {
            display: flex;
            width: 100%;
            align-items: flex-end; /* Align items to bottom for multi-line textarea */
            gap: 8px;
            padding: 8px;
            background-color: var(--input-field-bg);
            border-radius: var(--border-radius-base); /* More rounded for the whole input group */
            border: 1px solid var(--md-sys-color-outline);
        }
        #inputControls:focus-within {
            border-color: var(--md-sys-color-primary);
            box-shadow: 0 0 0 1px var(--md-sys-color-primary);
        }

        /* Icon Button Styling (Attach, Send) */
        .icon-btn {
            background: none;
            border: none;
            color: var(--md-sys-color-on-surface-variant);
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .icon-btn:hover {
            background-color: rgba(0,0,0,0.05);
            color: var(--md-sys-color-primary);
        }
        .icon-btn:disabled {
            color: var(--md-sys-color-outline);
            cursor: not-allowed;
        }
        .icon-btn .material-symbols-outlined {
            font-size: 24px;
        }
        #attachFilesBtn { /* No initial display: none; handled by JS */
             color: var(--md-sys-color-primary);
        }


        #tokenCounter, #scrollToggle {
          position: fixed;
          background-color: var(--md-sys-color-surface-variant);
          color: var(--md-sys-color-on-surface-variant);
          padding: 6px 12px;
          border-radius: 16px; /* Chip-like */
          z-index: 1000;
          font-family: var(--font-family);
          font-size: 13px; /* Smaller for chips */
          font-weight: 500;
          box-shadow: var(--elevation-1);
          transition: bottom 0.2s ease-out;
          display: inline-flex;
          align-items: center;
          gap: 6px;
        }
        #tokenCounter { right: 20px; }
        #scrollToggle { left: 20px; cursor: pointer; user-select: none; }
        #scrollToggle .material-symbols-outlined { font-size: 18px; }


        .message {
          position: relative;
          margin-bottom: var(--padding-base);
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          padding: calc(var(--padding-base) * 0.75) var(--padding-base);
          border-radius: var(--border-radius-base);
          max-width: 85%; /* Slightly less for more padding feel */
          box-shadow: var(--elevation-1);
          word-break: break-word; /* Ensure long words break */
        }

        .prefix {
          font-weight: 500; /* Material medium weight */
          flex-shrink: 0;
          margin-bottom: 0.25em;
          user-select: none;
          font-size: 0.875em; /* 14px */
          opacity: 0.9;
        }

        .content {
          flex-grow: 1;
        }

        .user {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            align-self: flex-end;
            border-bottom-right-radius: var(--border-radius-material); /* Chat bubble effect */
        }
        .user .prefix { color: var(--user-prefix-color); }

        .assistant {
            background-color: var(--md-sys-color-surface); /* Neutral surface for assistant */
            color: var(--md-sys-color-on-surface);
            align-self: flex-start;
            border-bottom-left-radius: var(--border-radius-material); /* Chat bubble effect */
        }
        .assistant .prefix { color: var(--assistant-color); }

        .system, .error {
            align-self: center;
            text-align: center;
            max-width: 90%;
            font-size: 0.9em;
            padding: calc(var(--padding-base) * 0.6);
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
            border-radius: var(--border-radius-material);
            box-shadow: none; /* Less prominent */
        }
        .system .prefix, .error .prefix {
            font-weight: 500;
        }
        .error {
            background-color: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
        }
        .error .prefix { color: var(--md-sys-color-error); }


        .system.help-output {
            text-align: left;
            align-self: flex-start;
            max-width: 95%;
            background-color: var(--md-sys-color-tertiary-container);
        }
        .system.help-output .prefix,
        .system.help-output .content {
            color: var(--md-sys-color-on-tertiary-container);
        }
        .system.help-output .content a {
            color: var(--md-sys-color-tertiary);
            text-decoration: underline;
        }
        .system.help-output code {
            background-color: rgba(0,0,0,0.08);
            color: var(--md-sys-color-on-tertiary-container);
            padding: 2px 5px;
            border-radius: var(--border-radius-material);
            font-family: 'Roboto Mono', Consolas, Monaco, monospace;
            font-size: 0.9em;
            border: 1px solid var(--md-sys-color-outline);
        }

        #userInput {
          flex-grow: 1;
          background-color: transparent; /* Inherits from #inputControls background */
          border: none;
          outline: none;
          color: var(--md-sys-color-on-surface);
          font-family: var(--font-family);
          font-size: inherit;
          line-height: var(--line-height);
          padding: 8px 0; /* Vertical padding */
          caret-color: var(--md-sys-color-primary);
          resize: none;
          overflow-y: hidden;
          min-height: calc(var(--line-height) * 1em + 16px); /* 1 line + padding */
        }
        #userInput::placeholder { color: var(--md-sys-color-on-surface-variant); font-style: normal; opacity: 1; }
        #userInput:disabled { cursor: not-allowed; opacity: 0.6; }

        .loading-content {
            display: inline-flex;
            align-items: baseline;
        }
        .thinking-timer-span {
            margin-left: 8px;
            font-size: 0.9em;
            opacity: 0.8;
            color: var(--system-color);
            white-space: nowrap;
        }

        /* Modal for Change Mode */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5); /* Dim overlay */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            margin: auto;
            padding: 20px;
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--border-radius-base);
            width: 80%;
            max-width: 400px;
            box-shadow: var(--elevation-2);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .modal-header h2 {
            margin: 0;
            font-size: 1.25em; /* 20px */
            font-weight: 500;
        }
        .close-modal-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--md-sys-color-on-surface-variant);
        }
        .close-modal-btn:hover {
            color: var(--md-sys-color-on-surface);
        }
        #modeList {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 200px;
            overflow-y: auto;
        }
        #modeList li button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--border-radius-material);
            text-align: left;
            cursor: pointer;
            font-size: 0.9em;
        }
        #modeList li button:hover {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            border-color: var(--md-sys-color-primary);
        }
        #modeList li button.active-mode {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            font-weight: 500;
        }


        .copy-btn {
          position: absolute;
          top: 6px;
          right: 6px;
          border: none;
          background: rgba(0,0,0,0.05);
          color: var(--md-sys-color-on-surface-variant);
          width: 32px;
          height: 32px;
          border-radius: 50%;
          font-family: var(--font-family);
          cursor: pointer;
          opacity: 0;
          user-select: none;
          transition: opacity 0.15s ease-in, background-color 0.15s ease-in;
          display: inline-flex;
          align-items: center;
          justify-content: center;
        }
        .copy-btn .material-symbols-outlined {
            font-size: 18px;
        }
        .copy-btn .copy-btn-text { display: none; } /* Hide text, use icon only */

        .message:hover .copy-btn { opacity: 0.7; }
        .copy-btn:hover { opacity: 1; background: rgba(0,0,0,0.1); color: var(--md-sys-color-primary); }
        .copy-btn:focus { outline: none; }


        @media (max-width: 600px) {
          html { font-size: var(--font-size-mobile); }
          main#terminal {
            padding: var(--padding-mobile) var(--padding-mobile) 0px var(--padding-mobile);
          }
          footer#inputArea { padding: calc(var(--padding-mobile) / 1.5) var(--padding-mobile); }
          #inputControls { padding: 6px; gap: 6px; }
          .icon-btn { width: 36px; height: 36px; padding: 6px; }
          .icon-btn .material-symbols-outlined { font-size: 22px; }

          #userInput { padding: 6px 0; min-height: calc(var(--line-height) * 1em + 12px); }
          .message { margin-bottom: calc(var(--padding-mobile) * 1.2); max-width: 95%; }
          main#terminal::-webkit-scrollbar { width: 6px; }
          #tokenCounter, #scrollToggle {
            bottom: 15px;
            padding: 5px 10px;
            font-size: 12px;
          }
          #tokenCounter { right: 15px; }
          #scrollToggle { left: 15px; }
          #scrollToggle .material-symbols-outlined { font-size: 16px; }

          #actionButtonsContainer { gap: 6px; margin-bottom: 6px; }
          .action-btn { padding: 5px 10px; font-size: 0.8em; }
          .action-btn .material-symbols-outlined { font-size: 1.1em; }

          .modal-content { width: 90%; }
        }

    </style>
</head>
<body>
    <main id="terminal"></main>

    <div id="tokenCounter">Token: 0</div>
    <div id="scrollToggle" class="floatingToggle">
        <span class="material-symbols-outlined">arrow_downward</span>
        <span>Scroll: ON</span>
    </div>

    <!-- Change Mode Modal -->
    <div id="changeModeModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Cambia Modalit√† IA</h2>
                <button id="closeModal" class="close-modal-btn"><span class="material-symbols-outlined">close</span></button>
            </div>
            <ul id="modeList">
                <!-- Modes will be populated by JavaScript -->
            </ul>
        </div>
    </div>

    <footer id="inputArea">
        <div id="actionButtonsContainer">
            <button id="helpBtn" class="action-btn" title="Mostra aiuto e comandi">
                <span class="material-symbols-outlined">help_outline</span> Aiuto
            </button>
            <button id="resetChatBtn" class="action-btn" title="Reimposta la chat">
                <span class="material-symbols-outlined">refresh</span> Reset
            </button>
            <button id="changeModeBtn" class="action-btn" title="Cambia modalit√† IA">
                <span class="material-symbols-outlined">tune</span> Modalit√†
            </button>
            <button id="stopAiBtn" class="action-btn" title="Interrompi risposta IA" style="display: none;">
                <span class="material-symbols-outlined">stop_circle</span> Stop AI
            </button>
        </div>
        <div id="fileListContainer">
            <strong>File allegati:</strong> <span id="fileListDisplay">Nessuno</span>
            <button id="clearFilesBtn" title="Rimuovi tutti i file">
                 <span class="material-symbols-outlined">delete_sweep</span>
            </button>
        </div>
        <div id="inputControls">
            <button id="attachFilesBtn" class="icon-btn" title="Allega file (max 15)">
                <span class="material-symbols-outlined">attach_file</span>
            </button>
            <input type="file" id="fileUploader" multiple accept=".pdf,.png,.jpg,.jpeg,.webp" style="display:none;">
            <textarea id="userInput" rows="1" placeholder="Inizializzazione..." autofocus autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" disabled></textarea>
            <button id="sendBtn" class="icon-btn" title="Invia messaggio" disabled>
                <span class="material-symbols-outlined">send</span>
            </button>
        </div>
    </footer>

    <script>
        const WORKER_URL = "https://germabyte-assistente-80.deno.dev/";

        const COMMAND_INFO = [
          { name: "help", desc: "help - Mostra questo messaggio di aiuto." },
          { name: "reset", desc: "reset - Reimposta il contesto della chat." },
          { name: "imposta modalit√†", desc: "imposta modalit√† <nome> - Cambia la modalit√† IA (es. fideiussione, estrazione-dati)." },
          { name: "stop", desc: "stop - Interrompe la risposta corrente dell'IA." }
        ];

        const terminalDiv = document.getElementById("terminal");
        const userInput = document.getElementById("userInput");
        const tokenCounterDiv = document.getElementById("tokenCounter");
        const scrollToggleDiv = document.getElementById("scrollToggle");
        // const promptSpan = document.getElementById("prompt"); // No longer used directly

        const attachFilesBtn = document.getElementById("attachFilesBtn");
        const fileUploader = document.getElementById("fileUploader");
        const fileListContainer = document.getElementById("fileListContainer");
        const fileListDisplay = document.getElementById("fileListDisplay");
        const clearFilesBtn = document.getElementById("clearFilesBtn");
        const sendBtn = document.getElementById("sendBtn");

        // Action Buttons
        const helpBtn = document.getElementById("helpBtn");
        const resetChatBtn = document.getElementById("resetChatBtn");
        const changeModeBtn = document.getElementById("changeModeBtn");
        const stopAiBtn = document.getElementById("stopAiBtn");

        // Modal Elements
        const changeModeModal = document.getElementById("changeModeModal");
        const closeModalBtn = document.getElementById("closeModal");
        const modeListUl = document.getElementById("modeList");


        const MAX_FILES = 15;
        const ALLOWED_MIMETYPES = ['application/pdf', 'image/png', 'image/jpeg', 'image/webp'];

        let autoScrollEnabled = true;
        function updateScrollToggleUI() {
            const icon = autoScrollEnabled ? "arrow_downward" : "pause";
            const text = autoScrollEnabled ? "Scroll: ON" : "Scroll: OFF";
            scrollToggleDiv.innerHTML = `<span class="material-symbols-outlined">${icon}</span> <span>${text}</span>`;
        }
        scrollToggleDiv.addEventListener("click", () => {
          autoScrollEnabled = !autoScrollEnabled;
          updateScrollToggleUI();
        });


        const appState = {
            conversation: [],
            commandHistory: [],
            historyIndex: -1,
            isWaitingForAI: false,
            currentCharacter: null,
            currentModel: null,
            availableCharacters: [],
            currentTokenCount: 0,
            currentTokenLimit: null,
            thinkingIntervalId: null,
            timerIntervalId: null,
            thinkingStartTime: null,
            abortController: null,
            loadingMsgDiv: null,
            uploadedFiles: [],
        };

        function formatTokenCount(num) {
            if (num === undefined || num === null) return '?';
            if (num < 1000) return num.toString();
            return (num / 1000).toFixed(1).replace(/\.0$/, '') + "k";
        }

        function appendMessage(role, text, isLoading = false, extraClass = null, overridePrefix = null) {
            const msgDiv = document.createElement("div");
            msgDiv.classList.add("message", role);
            if (extraClass) msgDiv.classList.add(extraClass);

            const prefixSpan = document.createElement("span");
            prefixSpan.classList.add("prefix");

            const contentSpan = document.createElement("span");
            contentSpan.classList.add("content");

            switch(role) {
                case 'user':
                    prefixSpan.textContent = "TU:"; // Changed for brevity
                    contentSpan.textContent = text;
                    break;
                case 'assistant':
                    prefixSpan.textContent = overridePrefix ?? `${(appState.currentCharacter || 'IA').toUpperCase()}:`;
                    if (isLoading) {
                        contentSpan.classList.add("loading-content");
                        contentSpan.innerHTML = `<span class="thinking-dots-span">Sto pensando.</span><span class="thinking-timer-span">(0.0s)</span>`;
                    } else {
                        contentSpan.innerHTML = text; // Use innerHTML for potential formatting
                    }
                    break;
                case 'system':
                    prefixSpan.textContent = "SISTEMA:";
                    contentSpan.innerHTML = text; // Use innerHTML for potential <code> tags etc.
                    break;
                case 'error':
                    prefixSpan.textContent = "ERRORE!";
                    contentSpan.textContent = text;
                    break;
                default:
                    prefixSpan.textContent = "???:";
                    contentSpan.textContent = text;
                    break;
            }

            msgDiv.appendChild(prefixSpan);
            msgDiv.appendChild(contentSpan);

            if (role === 'assistant' || role === 'user' || (role === 'system' && extraClass === 'help-output')) {
                const copyBtn = document.createElement("button");
                copyBtn.classList.add("copy-btn");
                copyBtn.setAttribute("title", "Copia messaggio");
                copyBtn.innerHTML = `<span class="material-symbols-outlined">content_copy</span><span class="copy-btn-text">Copia</span>`;

                copyBtn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  // Use innerText for copying to get plain text from formatted content
                  const textToCopy = contentSpan.innerText || contentSpan.textContent || "";
                  navigator.clipboard.writeText(textToCopy).then(() => {
                    copyBtn.innerHTML = `<span class="material-symbols-outlined">done</span><span class="copy-btn-text">Copiato!</span>`;
                    setTimeout(() => {
                        copyBtn.innerHTML = `<span class="material-symbols-outlined">content_copy</span><span class="copy-btn-text">Copia</span>`;
                    }, 1500);
                  }).catch(() => {
                    copyBtn.innerHTML = `<span class="material-symbols-outlined">close</span><span class="copy-btn-text">Errore</span>`;
                    setTimeout(() => {
                        copyBtn.innerHTML = `<span class="material-symbols-outlined">content_copy</span><span class="copy-btn-text">Copia</span>`;
                    }, 1500);
                  });
                });
                msgDiv.appendChild(copyBtn);
            }

            terminalDiv.appendChild(msgDiv);
            scrollToBottom();
            return msgDiv;
        }

        function scrollToBottom() {
          if (!autoScrollEnabled) return;
          requestAnimationFrame(() => {
            terminalDiv.scrollTo({ top: terminalDiv.scrollHeight, behavior: 'smooth' });
          });
        }

        function adjustTextareaHeight() {
            userInput.style.height = 'auto';
            let newHeight = userInput.scrollHeight;
            const maxHeight = 180; // Max height in pixels
            if (newHeight > maxHeight) {
                newHeight = maxHeight;
                userInput.style.overflowY = 'auto';
            } else {
                userInput.style.overflowY = 'hidden';
            }
            userInput.style.height = newHeight + 'px';

            const inputAreaElement = document.getElementById('inputArea');
            if (inputAreaElement) {
                terminalDiv.style.paddingBottom = `${inputAreaElement.offsetHeight + 8}px`; // Add some buffer
            }

            const inputAreaHeight = document.getElementById('inputArea')?.offsetHeight || 70;
            const baseOffset = 15; // Base offset from inputArea
            const newBottom = `${inputAreaHeight + baseOffset}px`;
            const newBottomMobile = `${inputAreaHeight + (baseOffset - 5)}px`;


            if (window.innerWidth <= 600) {
                tokenCounterDiv.style.bottom = newBottomMobile;
                scrollToggleDiv.style.bottom = newBottomMobile;
            } else {
                tokenCounterDiv.style.bottom = newBottom;
                scrollToggleDiv.style.bottom = newBottom;
            }
        }

        function updateTokenCounterUI() {
            const countStr = formatTokenCount(appState.currentTokenCount);
            const limitStr = formatTokenCount(appState.currentTokenLimit);
            tokenCounterDiv.textContent = `Token: ${countStr}${appState.currentTokenLimit !== null ? '/' + limitStr : ''}`;
        }

        function updateUIAfterModeOrFileChange() {
            const isEstrazioneDati = appState.currentCharacter === 'estrazione-dati';
            attachFilesBtn.style.display = isEstrazioneDati ? 'inline-flex' : 'none';

            if (isEstrazioneDati) {
                userInput.placeholder = appState.uploadedFiles.length > 0
                    ? "Premi Invio o aggiungi una nota per l'estrazione..."
                    : "Allega file (PDF, Immagini) per l'estrazione...";
                if (appState.uploadedFiles.length > 0) {
                    fileListContainer.style.display = 'flex'; // Changed to flex for alignment
                    clearFilesBtn.style.display = 'inline-flex';
                } else {
                    fileListContainer.style.display = 'none';
                    clearFilesBtn.style.display = 'none';
                }
            } else {
                fileListContainer.style.display = 'none';
                clearFilesBtn.style.display = 'none';
                userInput.placeholder = `Chiedi a ${appState.currentCharacter || 'IA'}...`;
            }
            adjustTextareaHeight();
        }


        function updateUserInteractionState() {
             const isDisabledByInitFailure = userInput.placeholder === "Inizializzazione fallita. Ricarica.";
             const disableInput = isDisabledByInitFailure || appState.isWaitingForAI || !appState.currentCharacter;

             userInput.disabled = disableInput;
             sendBtn.disabled = disableInput || (userInput.value.trim() === "" && !(appState.currentCharacter === 'estrazione-dati' && appState.uploadedFiles.length > 0));
             attachFilesBtn.disabled = disableInput; // Disable attach if AI is busy or not init

             // Action buttons
             helpBtn.disabled = appState.isWaitingForAI;
             resetChatBtn.disabled = appState.isWaitingForAI;
             changeModeBtn.disabled = appState.isWaitingForAI;
             stopAiBtn.style.display = appState.isWaitingForAI ? 'inline-flex' : 'none';


             if (appState.isWaitingForAI) {
                 userInput.placeholder = `IA sta rispondendo...`;
             } else if (isDisabledByInitFailure) {
                 // Placeholder already set
             } else if (!appState.currentCharacter) {
                 userInput.placeholder = "Caricamento configurazione...";
             } else {
                 updateUIAfterModeOrFileChange(); // Sets placeholder based on mode and files
             }
        }

        function startThinkingAnimationAndTimer() { /* Logic unchanged */
            if (!appState.loadingMsgDiv) return;
            const dotsSpan = appState.loadingMsgDiv.querySelector('.thinking-dots-span');
            const timerSpan = appState.loadingMsgDiv.querySelector('.thinking-timer-span');
            if (!dotsSpan || !timerSpan) return;
            let dotCount = 1;
            appState.thinkingIntervalId = setInterval(() => {
                dotCount = (dotCount % 3) + 1;
                dotsSpan.textContent = "Sto pensando" + ".".repeat(dotCount);
            }, 400);
            appState.thinkingStartTime = Date.now();
            timerSpan.textContent = `(0.0s)`;
            appState.timerIntervalId = setInterval(() => {
                const elapsedMilliseconds = Date.now() - appState.thinkingStartTime;
                const elapsedSecondsFormatted = (elapsedMilliseconds / 1000).toFixed(1);
                timerSpan.textContent = `(${elapsedSecondsFormatted}s)`;
            }, 100);
        }
        function clearThinkingAnimationAndTimer() { /* Logic unchanged */
            if (appState.thinkingIntervalId) clearInterval(appState.thinkingIntervalId);
            if (appState.timerIntervalId) clearInterval(appState.timerIntervalId);
            appState.thinkingIntervalId = null;
            appState.timerIntervalId = null;
            appState.thinkingStartTime = null;
            if (appState.loadingMsgDiv) {
                const contentSpan = appState.loadingMsgDiv.querySelector('.content');
                if (contentSpan) contentSpan.classList.remove('loading-content');
            }
        }
        function updateStateFromWorkerResponse(data) { /* Logic unchanged */
            if (data.activeCharacter) appState.currentCharacter = data.activeCharacter;
            if (data.activeModel) appState.currentModel = data.activeModel;
            if (data.availableCharacters) appState.availableCharacters = data.availableCharacters;
            if (typeof data.tokenCount === 'number') appState.currentTokenCount = data.tokenCount;
            if (typeof data.tokenLimit === 'number') appState.currentTokenLimit = data.tokenLimit;
            updateTokenCounterUI();
            updateUIAfterModeOrFileChange();
            populateModeModal(); // Update modal if characters change
        }
        function clearUploadedFiles() { /* Logic unchanged */
            appState.uploadedFiles = [];
            fileUploader.value = null;
            fileListDisplay.textContent = "Nessuno";
            updateUIAfterModeOrFileChange();
            updateUserInteractionState(); // Ensure send button state is correct
        }
        function resetConversationState(reason) { /* Logic unchanged */
            const reasonMap = { /* ... */ }; // Keep as is
            const italianReason = reasonMap[reason] || reason;
            appState.conversation = [];
            appState.currentTokenCount = 0;
            clearUploadedFiles();
            updateTokenCounterUI();
            appendMessage("system", `Contesto chat reimpostato (${italianReason}). Nuova conversazione avviata.`);
            updateUIAfterModeOrFileChange();
            scrollToBottom();
        }
        async function callWorkerApi(payload, signal) { /* Logic unchanged */
            let response;
            try {
                response = await fetch(WORKER_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                    signal
                });
                const data = await response.json();
                if (!response.ok) {
                    let errorMsg = `Errore API (${response.status})`;
                    errorMsg += `: ${data?.error || response.statusText}`;
                    if (data?.details) console.error("Dettagli Errore API:", data.details);
                    console.error("Risposta Errore API Completa:", data);
                    if (data?.availableCharacters) appState.availableCharacters = data.availableCharacters;
                    if (typeof data?.tokenLimit === 'number') appState.currentTokenLimit = data.tokenLimit;
                    if (typeof data?.tokenCount === 'number') appState.currentTokenCount = data.tokenCount;
                    updateTokenCounterUI();
                    const error = new Error(errorMsg);
                    error.status = response.status;
                    error.data = data;
                    throw error;
                }
                if (!data || (payload.messages && typeof data.completion !== 'string' && !signal?.aborted)) {
                     console.error("Struttura risposta API inattesa:", data);
                     throw new Error("Ricevuto un formato di risposta inatteso dall'API.");
                }
                updateStateFromWorkerResponse(data);
                return data;
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log("Fetch interrotto dall'utente.");
                    throw error;
                }
                console.error("Errore Fetch/API:", error);
                if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                     const networkError = new Error("Errore di rete. Impossibile raggiungere il worker API.");
                     networkError.status = 0;
                     throw networkError;
                }
                throw error;
            }
        }


        // --- New Button Handler Functions ---
        function handleHelpRequest() {
            appendMessage("user", "/help (tramite pulsante)");
            const commandsSorted = [...COMMAND_INFO].sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: "base" }));
            let helpOutput = "<b>COMANDI DISPONIBILI TRAMITE TERMINALE:</b>\n";
            commandsSorted.forEach(c => { helpOutput += `  <code>${c.desc}</code>\n`; });
            helpOutput += "\n<b>MODALIT√Ä DISPONIBILI (selezionabili tramite pulsante 'Modalit√†'):</b>\n";
            const chars = [...(appState.availableCharacters || [])].sort((a, b) => a.localeCompare(b));
            helpOutput += `  ${chars.length ? chars.map(c => `<code>${c}</code>`).join(', ') : 'Nessuna disponibile'}\n\n`;
            helpOutput += "<b>STATO ATTUALE:</b>\n";
            helpOutput += `  Modalit√†: ${appState.currentCharacter || 'N/D'}\n`;
            helpOutput += `  Modello:  ${appState.currentModel || 'N/D'}\n\n`;
            helpOutput += `<b>COME CHATTARE:</b>\n`;
            helpOutput += "  ‚Ä¢ Scrivi il tuo messaggio e premi Invia.\n";
            helpOutput += "  ‚Ä¢ Usa i pulsanti per le azioni comuni (Reset, Modalit√†, etc.).\n";
            helpOutput += "  ‚Ä¢ In modalit√† <code>estrazione-dati</code>, allega file usando il pulsante <span class='material-symbols-outlined' style='font-size: inherit; vertical-align: bottom;'>attach_file</span> e poi invia (puoi aggiungere una nota testuale opzionale).\n\n";
            appendMessage("system", helpOutput, false, "help-output");
        }

        function handleResetRequest() {
            appendMessage("user", "/reset (tramite pulsante)");
            resetConversationState('user command');
        }

        function handleStopAIRequest() {
            if (appState.abortController) {
                appendMessage("user", "/stop (tramite pulsante)");
                appState.abortController.abort();
                appendMessage("system", "Comando stop ricevuto. Richiesta IA interrotta.");
                // Cleanup handled in handleUserInput's finally block or error catch
            } else {
                appendMessage("error", "Impossibile fermare: Nessun processo IA attivo trovato.");
            }
        }

        function handleChangeModeRequest(modeName) {
            appendMessage("user", `/imposta modalit√† ${modeName} (tramite pulsante)`);
            const characterNameLower = modeName.toLowerCase();
            const foundCharacter = appState.availableCharacters.find(c => c.toLowerCase() === characterNameLower);

            if (foundCharacter) {
                 if (appState.currentCharacter !== foundCharacter) {
                     appState.currentCharacter = foundCharacter;
                     appendMessage("system", `Modalit√† impostata su: <b>${appState.currentCharacter}</b>.`);
                     resetConversationState('character change');
                 } else {
                      appendMessage("system", `La modalit√† √® gi√† impostata su: <b>${appState.currentCharacter}</b>.`);
                 }
            } else {
                 const sortedChars = [...(appState.availableCharacters || [])].sort((a, b) => a.localeCompare(b));
                 appendMessage("error", `Modalit√† '${modeName}' non trovata. Disponibili: ${sortedChars.map(c => `<code>${c}</code>`).join(', ') || 'Nessuna disponibile'}`);
            }
            closeChangeModeModal();
            updateUIAfterModeOrFileChange();
            updateUserInteractionState();
        }


        // --- Modal Logic ---
        function openChangeModeModal() {
            populateModeModal();
            changeModeModal.style.display = 'flex';
            setTimeout(() => userInput.focus(), 0); // Keep focus on input or modal
        }
        function closeChangeModeModal() {
            changeModeModal.style.display = 'none';
        }
        function populateModeModal() {
            modeListUl.innerHTML = ''; // Clear existing modes
            if (!appState.availableCharacters || appState.availableCharacters.length === 0) {
                modeListUl.innerHTML = '<li>Nessuna modalit√† disponibile.</li>';
                return;
            }
            const sortedChars = [...appState.availableCharacters].sort((a,b) => a.localeCompare(b));

            sortedChars.forEach(mode => {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.textContent = mode;
                if (mode === appState.currentCharacter) {
                    button.classList.add('active-mode');
                }
                button.onclick = () => handleChangeModeRequest(mode);
                li.appendChild(button);
                modeListUl.appendChild(li);
            });
        }

        // Event listeners for new buttons
        helpBtn.addEventListener('click', () => {
            if (appState.isWaitingForAI) return;
            handleHelpRequest();
        });
        resetChatBtn.addEventListener('click', () => {
            if (appState.isWaitingForAI) return;
            handleResetRequest();
        });
        stopAiBtn.addEventListener('click', handleStopAIRequest); // No waiting check, it's for stopping
        changeModeBtn.addEventListener('click', () => {
            if (appState.isWaitingForAI) return;
            openChangeModeModal();
        });
        closeModalBtn.addEventListener('click', closeChangeModeModal);
        window.addEventListener('click', (event) => { // Close modal if clicked outside
            if (event.target === changeModeModal) {
                closeChangeModeModal();
            }
        });


        async function handleUserInput() {
            const inputText = userInput.value.trim();

            if (appState.isWaitingForAI) { // Stop command from input field still possible
                if (inputText.toLowerCase() === 'stop') {
                    handleStopAIRequest();
                    userInput.value = ""; adjustTextareaHeight(); updateUserInteractionState();
                } else if (inputText !== "") { // User typed something else while AI is busy
                    appendMessage("user", inputText);
                    userInput.value = ""; adjustTextareaHeight(); updateUserInteractionState();
                    appendMessage("system", `Input "${inputText}" ignorato: IA occupata. Usa il pulsante 'Stop AI' o digita 'stop' per interrompere.`);
                }
                return;
            }

            // Handle empty input based on mode
            if (appState.currentCharacter !== 'estrazione-dati' && inputText === "") {
                userInput.value = ""; adjustTextareaHeight(); updateUserInteractionState();
                return;
            }
            if (appState.currentCharacter === 'estrazione-dati' && inputText === "" && appState.uploadedFiles.length === 0) {
                appendMessage("system", "Per l'estrazione dati, per favore allega prima dei file o fornisci un input testuale.");
                userInput.value = ""; adjustTextareaHeight(); updateUserInteractionState();
                return;
            }

            // Add to command history only if it's a pure text input and not a button-triggered action
            const currentInputTextForHistory = (appState.currentCharacter === 'estrazione-dati' && appState.uploadedFiles.length > 0)
                ? (inputText || `[${appState.uploadedFiles.length} file allegati]`)
                : inputText;

            if (currentInputTextForHistory && (appState.commandHistory.length === 0 || appState.commandHistory[appState.commandHistory.length - 1] !== currentInputTextForHistory)) {
                appState.commandHistory.push(currentInputTextForHistory);
            }
            appState.historyIndex = appState.commandHistory.length;


            // Command parsing for text input (less critical now with buttons, but keep for flexibility)
            const commandArgs = inputText.toLowerCase().split(/\s+/);
            const command = commandArgs[0];

            // Allow 'help', 'reset', 'imposta modalit√†' from terminal for power users or if buttons fail
            if (command === 'help' || command === 'h') {
                handleHelpRequest();
                userInput.value = ""; adjustTextareaHeight(); updateUserInteractionState();
                return;
            }
            if (command === 'reset' || command === 'r') {
                handleResetRequest();
                userInput.value = ""; adjustTextareaHeight(); updateUserInteractionState();
                return;
            }
            if (command === 'imposta' && commandArgs.length >= 3 && commandArgs[1] === 'modalit√†') {
                const modeName = inputText.split(/\s+/).slice(2).join(' ');
                handleChangeModeRequest(modeName); // Use the same handler
                userInput.value = ""; adjustTextareaHeight(); updateUserInteractionState();
                return;
            }


            // Regular chat or estrazione-dati submission
            let userMessageForConversation;
            let displayUserTextInChat;

            if (appState.currentCharacter === 'estrazione-dati') {
                if (appState.uploadedFiles.length === 0 && inputText === "") { // Should be caught above, but double check
                    appendMessage("system", "Per l'estrazione dati, allega file o scrivi una nota.");
                    return;
                }
                displayUserTextInChat = inputText || `Estrazione dati da ${appState.uploadedFiles.length} file.`;
                const userMessageContentArray = [{ type: "text", text: inputText || "Estrai i dati dai documenti allegati come richiesto." }];

                appState.uploadedFiles.forEach(file => {
                    if (file.type.startsWith('image/')) {
                        userMessageContentArray.push({ type: "image_url", image_url: { url: file.dataUrl } });
                    } else if (file.type === 'application/pdf') {
                        userMessageContentArray.push({ type: "file", file: { filename: file.name, file_data: file.dataUrl }});
                    }
                });
                userMessageForConversation = { role: "user", content: userMessageContentArray };
            } else { // Standard text chat
                if (inputText === "") return; // Already handled but good to be defensive
                displayUserTextInChat = inputText;
                userMessageForConversation = { role: "user", content: inputText };
            }

            appendMessage("user", displayUserTextInChat);
            appState.conversation.push(userMessageForConversation);
            userInput.value = ""; // Clear input after processing
            adjustTextareaHeight();
            scrollToBottom();

            appState.isWaitingForAI = true;
            appState.loadingMsgDiv = appendMessage("assistant", "", true);
            startThinkingAnimationAndTimer();
            appState.abortController = new AbortController();
            updateUserInteractionState(); // Disables input, shows stop button etc.

            try {
                const payload = {
                    messages: appState.conversation,
                    character: appState.currentCharacter,
                    model: appState.currentModel
                };
                const result = await callWorkerApi(payload, appState.abortController.signal);
                clearThinkingAnimationAndTimer();

                if (appState.loadingMsgDiv && !appState.abortController.signal.aborted) {
                     const contentSpan = appState.loadingMsgDiv.querySelector('.content');
                     const prefixSpan = appState.loadingMsgDiv.querySelector('.prefix');
                     if (contentSpan && prefixSpan) {
                         contentSpan.classList.remove('loading-content');
                         prefixSpan.textContent = `${(appState.currentCharacter || 'IA').toUpperCase()}:`;
                         contentSpan.innerHTML = result.completion; // Use innerHTML
                     } else {
                         if(appState.loadingMsgDiv) appState.loadingMsgDiv.remove();
                         appendMessage("assistant", result.completion);
                     }
                } else if (appState.loadingMsgDiv) {
                    appState.loadingMsgDiv.remove(); // Ensure removal if aborted early
                }
                appState.loadingMsgDiv = null;

                if (result.completion !== undefined && !appState.abortController.signal.aborted) {
                    appState.conversation.push({ role: "assistant", content: result.completion });
                    if (appState.currentCharacter === 'estrazione-dati') {
                        clearUploadedFiles();
                    }
                }

                if (appState.currentTokenLimit !== null && appState.currentTokenCount >= appState.currentTokenLimit) {
                    appendMessage("system", `Limite token (${formatTokenCount(appState.currentTokenLimit)}) raggiunto. Reimpostazione automatica del contesto.`);
                    resetConversationState('token limit');
                }

            } catch (error) {
                clearThinkingAnimationAndTimer();
                if (appState.loadingMsgDiv) {
                    appState.loadingMsgDiv.remove();
                    appState.loadingMsgDiv = null;
                }
                if (error.name !== 'AbortError') {
                    appendMessage("error", error.message || "Si √® verificato un errore sconosciuto.");
                    if (error.status === 413 || (error.message && error.message.includes("Token limit reached before processing"))) {
                        appendMessage("system", "Messaggio di input troppo lungo o limite contesto raggiunto. Reimpostazione automatica del contesto.");
                        resetConversationState('input limit');
                    }
                }
                 // State already updated by abort handler if that's the case
            } finally {
                clearThinkingAnimationAndTimer();
                appState.isWaitingForAI = false;
                appState.abortController = null;
                if (appState.loadingMsgDiv) {
                    appState.loadingMsgDiv.remove();
                    appState.loadingMsgDiv = null;
                }
                updateUserInteractionState(); // Re-enable input, hide stop button etc.
                if (userInput.placeholder !== "Inizializzazione fallita. Ricarica.") {
                   setTimeout(() => userInput.focus(), 50);
                }
            }
        }

        function handleKeyDown(event) { /* Logic largely unchanged, but Enter now calls handleUserInput */
            if (event.key === "Enter" && !event.shiftKey && !userInput.disabled) {
                event.preventDefault();
                handleUserInput();
            }
            else if (event.key === "ArrowUp" && !userInput.disabled && userInput.selectionStart === 0 && userInput.selectionEnd === 0) {
                if (appState.commandHistory.length > 0 && appState.historyIndex > 0) {
                    event.preventDefault();
                    appState.historyIndex--;
                    userInput.value = appState.commandHistory[appState.historyIndex];
                    requestAnimationFrame(() => { userInput.setSelectionRange(userInput.value.length, userInput.value.length); });
                    adjustTextareaHeight(); updateUserInteractionState();
                }
            }
            else if (event.key === "ArrowDown" && !userInput.disabled && userInput.selectionStart === userInput.value.length && userInput.selectionEnd === userInput.value.length) {
                 if (appState.historyIndex < appState.commandHistory.length - 1) {
                    event.preventDefault();
                    appState.historyIndex++;
                    userInput.value = appState.commandHistory[appState.historyIndex];
                    requestAnimationFrame(() => { userInput.setSelectionRange(userInput.value.length, userInput.value.length); });
                    adjustTextareaHeight(); updateUserInteractionState();
                } else if (appState.historyIndex === appState.commandHistory.length - 1) {
                    event.preventDefault();
                    appState.historyIndex++;
                    userInput.value = "";
                    adjustTextareaHeight(); updateUserInteractionState();
                }
            }
        }

        // --- File Upload Logic (mostly unchanged, UI updates handled by updateUIAfterModeOrFileChange) ---
        attachFilesBtn.addEventListener('click', () => fileUploader.click());
        clearFilesBtn.addEventListener('click', () => {
            clearUploadedFiles();
            appendMessage("system", "File allegati rimossi.");
        });

        fileUploader.addEventListener('change', (event) => { /* Logic mostly unchanged */
            const files = event.target.files;
            if (!files || files.length === 0) {
                if (appState.uploadedFiles.length === 0) {
                    fileListDisplay.textContent = "Nessuno";
                }
                updateUIAfterModeOrFileChange();
                updateUserInteractionState();
                return;
            }

            if (appState.uploadedFiles.length + files.length > MAX_FILES) {
                 appendMessage("error", `Puoi caricare un massimo di ${MAX_FILES} file in totale. Hai gi√† ${appState.uploadedFiles.length} file.`);
                 fileUploader.value = null; // Clear the input so user can reselect
                 return;
            }


            const fileReadPromises = [];
            let invalidFileFound = false;
            let newFilesCount = 0;

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (!ALLOWED_MIMETYPES.includes(file.type)) {
                    appendMessage("error", `Tipo di file non supportato: ${file.name} (${file.type}). Consentiti: PDF, PNG, JPG, WEBP.`);
                    invalidFileFound = true;
                    continue;
                }
                 // Check for duplicates by name (simple check)
                if (appState.uploadedFiles.some(existingFile => existingFile.name === file.name)) {
                    appendMessage("system", `File '${file.name}' gi√† allegato.`);
                    continue;
                }

                newFilesCount++;
                const reader = new FileReader();
                const promise = new Promise((resolve, reject) => {
                    reader.onload = (e) => {
                        appState.uploadedFiles.push({
                            name: file.name,
                            type: file.type,
                            dataUrl: e.target.result
                        });
                        resolve();
                    };
                    reader.onerror = (e) => {
                        console.error("Errore lettura file:", file.name, e);
                        appendMessage("error", `Errore durante la lettura del file: ${file.name}`);
                        reject(e);
                    };
                    reader.readAsDataURL(file);
                });
                fileReadPromises.push(promise);
            }

            Promise.all(fileReadPromises)
                .then(() => {
                    if (appState.uploadedFiles.length > 0) {
                        const names = appState.uploadedFiles.map(f => f.name).join(', ');
                        fileListDisplay.textContent = names;
                        if (newFilesCount > 0) { // Only show message if new files were actually added
                           appendMessage("system", `${newFilesCount} file aggiunt${newFilesCount > 1 ? 'i' : 'o'}. Totale: ${appState.uploadedFiles.length}.`);
                        }
                    } else if (!invalidFileFound) { // No files and no errors means dialog was cancelled or only duplicates were selected
                         fileListDisplay.textContent = "Nessuno";
                    }
                    // If invalidFileFound is true but uploadedFiles is 0, it means all selected files were invalid or failed.
                    // In this case, the error messages for each file are sufficient.
                    updateUIAfterModeOrFileChange();
                    updateUserInteractionState();
                })
                .catch(() => {
                    if (appState.uploadedFiles.length === 0) clearUploadedFiles(); // Clears and updates UI
                    else { updateUIAfterModeOrFileChange(); updateUserInteractionState(); }
                });
            fileUploader.value = null; // Reset file input to allow selecting the same file again if removed
        });


        async function initializeApp() {
            appendMessage("system", `Sessione avviata: ${new Date().toLocaleString('it-IT')}`);
            updateTokenCounterUI();
            updateScrollToggleUI();
            updateUserInteractionState(); // Initial state for buttons and input
            adjustTextareaHeight();
            scrollToBottom();

            appendMessage("system", "Recupero configurazione...");
            try {
                await callWorkerApi({ type: 'init' });
                appendMessage("system", `Configurazione caricata.`);
                appendMessage("system", `Modalit√† iniziale: <b>${appState.currentCharacter}</b>. Modello: ${appState.currentModel}.`);
                appendMessage("system", `Usa il pulsante <span class='material-symbols-outlined' style='font-size: inherit; vertical-align: bottom;'>help_outline</span> Aiuto per i comandi o i pulsanti azione.`);
                populateModeModal(); // Populate modal with available characters
            } catch (error) {
                appendMessage("error", `Inizializzazione fallita: ${error.message}`);
                appendMessage("system", "Impossibile caricare la configurazione. Funzionalit√† limitate. Prova a ricaricare la pagina.");
                userInput.placeholder = "Inizializzazione fallita. Ricarica.";
                // isWaitingForAI remains false, but input is disabled by updateUserInteractionState
            } finally {
                 appState.isWaitingForAI = false; // Ensure this is false after init
                 updateUserInteractionState(); // Final state update
                 setTimeout(() => userInput.focus(), 0);
                 scrollToBottom();
            }
        }

        userInput.addEventListener("keydown", handleKeyDown);
        userInput.addEventListener("input", () => {
            adjustTextareaHeight();
            updateUserInteractionState(); // Update send button state based on input
        });
        sendBtn.addEventListener("click", () => {
            if (!sendBtn.disabled) {
                handleUserInput();
            }
        });

        terminalDiv.addEventListener('click', (event) => {
            if (event.target === terminalDiv || (terminalDiv.contains(event.target) && event.target.tagName !== 'A' && !event.target.closest('.copy-btn') && !event.target.closest('button'))) {
                if (window.getSelection().toString() === '' && !appState.isWaitingForAI && !userInput.disabled) {
                   userInput.focus();
                }
            }
        });

        window.addEventListener('resize', adjustTextareaHeight);

        initializeApp();
    </script>
</body>
</html>
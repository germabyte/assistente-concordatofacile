<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Assistente ConcordatoFacile</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='10 0 100 100'><text y='.9em' font-size='90'>ü§ñ</text></svg>">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #F3F5FA;
            --text-color: #2D3748;
            --input-bg-color: #ffffff;
            --border-color: #E2E8F0;
            --prompt-color: #3182CE;
            --assistant-color: #805AD5;
            --system-color: #718096;
            --error-color: #E53E3E;
            --font-family: 'Inter', sans-serif;
            --font-size-base: 16px;
            --line-height: 1.6;
            --padding: 16px;
            --border-radius: 12px;
            --shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            font-family: var(--font-family);
            font-size: var(--font-size-base);
            background: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            overflow: hidden;
        }

        #terminal {
            flex: 1;
            padding: var(--padding);
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        #terminal::-webkit-scrollbar {
            width: 8px;
        }

        #terminal::-webkit-scrollbar-track {
            background: transparent;
        }

        #terminal::-webkit-scrollbar-thumb {
            background: rgba(113,128,150,0.3);
            border-radius: var(--border-radius);
        }

        #inputArea {
            display: flex;
            align-items: center;
            padding: var(--padding);
            background: var(--input-bg-color);
            box-shadow: var(--shadow);
            border-top: 1px solid var(--border-color);
        }

        #prompt {
            margin-right: 8px;
            font-weight: 600;
            color: var(--prompt-color);
        }

        #userInput {
            flex: 1;
            border: none;
            outline: none;
            background: none;
            font-family: inherit;
            font-size: inherit;
            resize: none;
            padding: 6px;
            overflow-y: auto;
            color: var(--text-color);
        }

        .message {
            padding: var(--padding);
            margin-bottom: 12px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            position: relative;
            transition: transform 0.15s;
        }

        .message:hover {
            transform: translateY(-2px);
        }

        .prefix {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .user {
            background-color: rgba(49,130,206,0.1);
            align-self: flex-end;
        }

        .assistant {
            background-color: rgba(128,90,213,0.1);
        }

        .system, .error {
            background-color: rgba(113,128,150,0.1);
            text-align: center;
        }

        .error {
            background-color: rgba(229,62,62,0.1);
            color: var(--error-color);
            font-weight: 500;
        }

        #tokenCounter, #scrollToggle {
            position: fixed;
            bottom: 90px;
            background: rgba(255,255,255,0.9);
            padding: 8px 14px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            font-size: 14px;
            cursor: pointer;
            user-select: none;
        }

        #tokenCounter {
            right: 20px;
        }

        #scrollToggle {
            left: 20px;
        }

        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: var(--border-radius);
            background-color: rgba(113,128,150,0.15);
            color: var(--text-color);
            opacity: 0;
            cursor: pointer;
            border: none;
            transition: opacity 0.15s;
        }

        .message:hover .copy-btn {
            opacity: 1;
        }

        @media (max-width: 600px) {
            #inputArea, #terminal {
                padding: 12px;
            }
            #tokenCounter, #scrollToggle {
                bottom: 80px;
                padding: 6px 10px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <main id="terminal"></main>

    <div id="tokenCounter">Token: 0</div>
    <div id="scrollToggle">üîΩ Scroll Automatico: ON</div>

    <footer id="inputArea">
        <span id="prompt">&gt;</span>
        <textarea id="userInput" rows="1" placeholder="Inizializzazione..." autofocus autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" disabled></textarea>
    </footer>

    <!-- Existing JavaScript remains unchanged here. -->
    <script>
        const WORKER_URL = "https://germabyte-assistente-80.deno.dev/";

		const COMMAND_INFO = [
		  { name: "help", desc: "help - Mostra questo messaggio di aiuto." },
		  { name: "reset", desc: "reset - Reimposta il contesto della chat." },
		  { name: "imposta modalit√†", desc: "imposta modalit√† &lt;nome&gt; - Cambia la modalit√† AI (reimposta contesto)." },
		  { name: "stop", desc: "stop - Interrompe la risposta corrente dell'AI." }
		];

        const terminalDiv = document.getElementById("terminal");
        const userInput = document.getElementById("userInput");
        const tokenCounterDiv = document.getElementById("tokenCounter");

		let autoScrollEnabled = true;
		const scrollToggleDiv = document.getElementById("scrollToggle");
		scrollToggleDiv.addEventListener("click", () => {
		  autoScrollEnabled = !autoScrollEnabled;
		  scrollToggleDiv.textContent = autoScrollEnabled
			? "üîΩ Scroll Automatico: ON"
			: "‚è∏Ô∏è Scroll Automatico: OFF";
		});

        const promptSpan = document.getElementById("prompt");

        const appState = {
            conversation: [],
            commandHistory: [],
            historyIndex: -1,
            isWaitingForAI: false,
            currentCharacter: null,
            currentModel: null,
            availableCharacters: [],
            currentTokenCount: 0,
            currentTokenLimit: null,
            thinkingIntervalId: null,
            timerIntervalId: null,
            thinkingStartTime: null,
            abortController: null,
            loadingMsgDiv: null,
        };

        function formatTokenCount(num) {
            if (num === undefined || num === null) return '?';
            if (num < 1000) return num.toString();
            return (num / 1000).toFixed(1).replace(/\.0$/, '') + "k";
        }

        function appendMessage(role, text, isLoading = false, extraClass = null, overridePrefix = null) {
            const msgDiv = document.createElement("div");
            msgDiv.classList.add("message", role);

            if (extraClass) {
                msgDiv.classList.add(extraClass);
            }

            const prefixSpan = document.createElement("span");
            prefixSpan.classList.add("prefix");

            const contentSpan = document.createElement("span");
            contentSpan.classList.add("content");

            switch(role) {
                case 'user':
                    prefixSpan.textContent = "UTENTE:";
                    contentSpan.textContent = text;
                    break;
                case 'assistant':
                    prefixSpan.textContent = overridePrefix ?? `${(appState.currentCharacter || 'AI').toUpperCase()}:`;
                    if (isLoading) {
                        contentSpan.classList.add("loading-content");
                        contentSpan.innerHTML = `<span class="thinking-dots-span">Sto pensando.</span><span class="thinking-timer-span">(0.0s)</span>`;
                    } else {
                        contentSpan.textContent = text;
                    }
                    break;
				case 'system':
					prefixSpan.textContent = "SISTEMA:";
					extraClass === 'help-output' ? contentSpan.innerHTML = text : contentSpan.textContent = text;
					break;
                case 'error':
                    prefixSpan.textContent = "ERRORE!";
                    contentSpan.textContent = text;
                    break;
                default:
                    prefixSpan.textContent = "???:";
                    contentSpan.textContent = text;
                    break;
            }

			msgDiv.appendChild(prefixSpan);
			msgDiv.appendChild(contentSpan);

			const copyBtn = document.createElement("button");
			copyBtn.classList.add("copy-btn");
			copyBtn.setAttribute("title", "Copia questo messaggio");
			copyBtn.textContent = "Copia";

			copyBtn.addEventListener("click", (e) => {
			  e.stopPropagation();
			  const txt = contentSpan.textContent || "";
			  navigator.clipboard.writeText(txt).then(() => {
				copyBtn.textContent = "Copiato!";
				setTimeout(() => (copyBtn.textContent = "Copia"), 1500);
			  }).catch(() => {
				copyBtn.textContent = "Errore";
				setTimeout(() => (copyBtn.textContent = "Copia"), 1500);
			  });
			});

			msgDiv.appendChild(copyBtn);

			terminalDiv.appendChild(msgDiv);
			scrollToBottom();
			return msgDiv;
		}

		function scrollToBottom() {
		  if (!autoScrollEnabled) return;
		  requestAnimationFrame(() => {
			terminalDiv.scrollTo({ top: terminalDiv.scrollHeight, behavior: 'smooth' });
		  });
		}

        function adjustTextareaHeight() {
            userInput.style.height = 'auto';
            let newHeight = userInput.scrollHeight;
            const maxHeight = 180;
            if (newHeight > maxHeight) {
                newHeight = maxHeight;
                userInput.style.overflowY = 'auto';
            } else {
                userInput.style.overflowY = 'hidden';
            }
            userInput.style.height = newHeight + 'px';

            const inputArea = document.getElementById('inputArea');

			if (inputArea) {
			  const inputAreaHeight = inputArea.offsetHeight;
			  const newBottom = `${inputAreaHeight + 15}px`;
			  tokenCounterDiv.style.bottom    = newBottom;
			  scrollToggleDiv.style.bottom    = newBottom;
			}
        }

		function updateTokenCounterUI() {
			const countStr = formatTokenCount(appState.currentTokenCount);
			const limitStr = formatTokenCount(appState.currentTokenLimit);
			tokenCounterDiv.textContent = `Token: ${countStr}${appState.currentTokenLimit !== null ? '/' + limitStr : ''}`;
		}

        function updatePromptUI() {
            promptSpan.textContent = "> ";
        }

        function updateUserInteractionState() {
             const isDisabled = userInput.placeholder === "Inizializzazione fallita. Ricarica.";
             userInput.disabled = isDisabled;

             if (appState.isWaitingForAI) {
                 userInput.placeholder = `Digita 'stop' per interrompere`;
             } else if (isDisabled) {
                 // Keep disabled placeholder
             } else if (!appState.currentCharacter) {
                 userInput.placeholder = "Caricamento config...";
             } else {
                 userInput.placeholder = `Chiedi all'IA...`;
             }
             adjustTextareaHeight();
        }

        function startThinkingAnimationAndTimer() {
            if (!appState.loadingMsgDiv) return;

            const dotsSpan = appState.loadingMsgDiv.querySelector('.thinking-dots-span');
            const timerSpan = appState.loadingMsgDiv.querySelector('.thinking-timer-span');
            if (!dotsSpan || !timerSpan) return;

            let dotCount = 1;
            appState.thinkingIntervalId = setInterval(() => {
                dotCount = (dotCount % 3) + 1;
                dotsSpan.textContent = "Sto pensando" + ".".repeat(dotCount);
            }, 400);

            appState.thinkingStartTime = Date.now();
            timerSpan.textContent = `(0.0s)`;
            appState.timerIntervalId = setInterval(() => {
                const elapsedMilliseconds = Date.now() - appState.thinkingStartTime;
                const elapsedSecondsFormatted = (elapsedMilliseconds / 1000).toFixed(1);
                timerSpan.textContent = `(${elapsedSecondsFormatted}s)`;
            }, 100);
        }

        function clearThinkingAnimationAndTimer() {
            if (appState.thinkingIntervalId) {
                clearInterval(appState.thinkingIntervalId);
                appState.thinkingIntervalId = null;
            }
            if (appState.timerIntervalId) {
                clearInterval(appState.timerIntervalId);
                appState.timerIntervalId = null;
            }
            appState.thinkingStartTime = null;
            if (appState.loadingMsgDiv) {
                const contentSpan = appState.loadingMsgDiv.querySelector('.content');
                if (contentSpan) {
                    contentSpan.classList.remove('loading-content');
                }
            }
        }

        function updateStateFromWorkerResponse(data) {
            if (data.activeCharacter) appState.currentCharacter = data.activeCharacter;
            if (data.activeModel) appState.currentModel = data.activeModel;
            if (data.availableCharacters) appState.availableCharacters = data.availableCharacters;
            if (typeof data.tokenCount === 'number') appState.currentTokenCount = data.tokenCount;
            if (typeof data.tokenLimit === 'number') appState.currentTokenLimit = data.tokenLimit;

            updateTokenCounterUI();
            updatePromptUI();
        }

        function resetConversationState(reason) {
            const reasonMap = {
                'user command': 'comando utente',
                'character change': 'cambio modalit√†',
                'token limit': 'limite token',
                'input limit': 'limite input'
            };
            const italianReason = reasonMap[reason] || reason;

            appState.conversation = [];
            appState.currentTokenCount = 0;
            updateTokenCounterUI();
            appendMessage("system", `Contesto chat reimpostato (${italianReason}). Nuova conversazione avviata.`);
            scrollToBottom();
        }

        async function callWorkerApi(payload, signal) {
            let response;
            try {
                response = await fetch(WORKER_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                    signal
                });

                const data = await response.json();

                if (!response.ok) {
                    let errorMsg = `Errore API (${response.status})`;
                    errorMsg += `: ${data?.error || response.statusText}`;
                    if (data?.details) console.error("Dettagli Errore API:", data.details);
                    console.error("Risposta Errore API Completa:", data);

                    if (data?.availableCharacters) appState.availableCharacters = data.availableCharacters;
                    if (typeof data?.tokenLimit === 'number') appState.currentTokenLimit = data.tokenLimit;
                    if (typeof data?.tokenCount === 'number') appState.currentTokenCount = data.tokenCount;
                    updateTokenCounterUI();

                    const error = new Error(errorMsg);
                    error.status = response.status;
                    error.data = data;
                    throw error;
                }

                if (!data || (payload.messages && typeof data.completion !== 'string' && !signal?.aborted)) {
                     console.error("Struttura risposta API inattesa:", data);
                     throw new Error("Ricevuto un formato di risposta inatteso dall'API.");
                }

                updateStateFromWorkerResponse(data);

                return data;

            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log("Fetch interrotto dall'utente.");
                    throw error;
                }

                console.error("Errore Fetch/API:", error);
                if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                     const networkError = new Error("Errore di rete. Impossibile raggiungere il worker API.");
                     networkError.status = 0;
                     throw networkError;
                }
                throw error;
            }
        }

        async function handleUserInput() {
            const inputText = userInput.value.trim();
            userInput.value = "";
            adjustTextareaHeight();

            if (inputText === "") return;

            if (appState.isWaitingForAI) {
                if (inputText.toLowerCase() === 'stop') {
                    appendMessage("user", inputText);
                    if (appState.abortController) {
                        appState.abortController.abort();
                        appendMessage("system", "Comando stop ricevuto. Richiesta AI interrotta.");
                        clearThinkingAnimationAndTimer();
                        if (appState.loadingMsgDiv) {
                            appState.loadingMsgDiv.remove();
                            appState.loadingMsgDiv = null;
                        }
                        appState.isWaitingForAI = false;
                        appState.abortController = null;
                        updateUserInteractionState();
                    } else {
                        appendMessage("error", "Impossibile fermare: Nessun processo AI attivo trovato.");
                    }
                } else {
                    appendMessage("user", inputText);
                    appendMessage("system", `Input "${inputText}" ignorato: AI occupata. Digita 'stop' per interrompere.`);
                }
                scrollToBottom();
                return;
            }

            if (appState.commandHistory.length === 0 || appState.commandHistory[appState.commandHistory.length - 1] !== inputText) {
                appState.commandHistory.push(inputText);
            }
            appState.historyIndex = appState.commandHistory.length;

            const commandArgs = inputText.toLowerCase().split(/\s+/);
            const command = commandArgs[0];
            const subCommand = commandArgs.slice(0,2).join(' ');
            const originalArgs = inputText.split(/\s+/);

            if (command === 'reset') {
                appendMessage("user", inputText);
                resetConversationState('user command');
                return;
            }

            if (command === 'help') {
                appendMessage("user", inputText);

				const commandsSorted = [...COMMAND_INFO].sort((a, b) =>
					a.name.localeCompare(b.name, undefined, { sensitivity: "base" })
				);

				let helpOutput = "<b>COMANDI:</b>\n";
				commandsSorted.forEach(c => {
					helpOutput += `  <code>${c.desc}</code>\n`;
				});
				helpOutput += "\n<b>MODALIT√Ä DISPONIBILI:</b>\n";
				const chars = [...(appState.availableCharacters || [])].sort((a, b) => a.localeCompare(b));
				helpOutput += `  ${chars.length ? chars.join(', ') : 'Nessuna disponibile'}\n\n`;
				helpOutput += "<b>STATO ATTUALE:</b>\n";
				helpOutput += `  Modalit√†: ${appState.currentCharacter || 'N/D'}\n`;
				helpOutput += `  Modello:  ${appState.currentModel || 'N/D'}\n\n`;
				helpOutput += `<b>COME CHATTARE:</b>\n`;
				helpOutput += "  ‚Ä¢ Scrivi semplicemente qualsiasi cosa che non sia un comando per chattare con la modalit√† AI corrente.\n\n";
				appendMessage("system", helpOutput, false, "help-output");
				scrollToBottom();
				return;
            }

            if (command === 'imposta') {
                appendMessage("user", inputText);
                if (originalArgs.length < 3) {
                     appendMessage("error", "Utilizzo: imposta modalit√† <nome>");
                     return;
                }
                const settingType = commandArgs[1]; // Should be 'modalit√†'
                const settingValue = originalArgs.slice(2).join(' ');

                if (settingType === 'modalit√†') {
                     const characterNameLower = settingValue.toLowerCase();
                     const foundCharacter = appState.availableCharacters.find(c => c.toLowerCase() === characterNameLower);

                     if (foundCharacter) {
                         if (appState.currentCharacter !== foundCharacter) {
                             appState.currentCharacter = foundCharacter;
                             appendMessage("system", `Modalit√† impostata su: ${appState.currentCharacter}.`);
                             resetConversationState('character change'); // Internal key remains 'character change'
                             updatePromptUI();
                         } else {
                              appendMessage("system", `La modalit√† √® gi√† impostata su: ${appState.currentCharacter}.`);
                         }
                     } else {
                         const sortedChars = [...(appState.availableCharacters || [])].sort((a, b) => a.localeCompare(b));
                         appendMessage("error", `Modalit√† '${settingValue}' non trovata. Disponibili: ${sortedChars.join(', ') || 'Nessuna disponibile'}`);
                     }
                } else {
                     appendMessage("error", "Tipo di impostazione sconosciuto. Usa 'modalit√†'.");
                }
                 scrollToBottom();
                 return;
            }

            appendMessage("user", inputText);
            appState.conversation.push({ role: "user", content: inputText });
            scrollToBottom();

            appState.isWaitingForAI = true;
            appState.loadingMsgDiv = appendMessage("assistant", "", true);
            startThinkingAnimationAndTimer();
            appState.abortController = new AbortController();
            updateUserInteractionState();

            try {
                const payload = {
                    messages: appState.conversation,
                    character: appState.currentCharacter, // Backend expects 'character' key
                    model: appState.currentModel
                };
                const result = await callWorkerApi(payload, appState.abortController.signal);

                clearThinkingAnimationAndTimer();

                if (appState.loadingMsgDiv && !appState.abortController.signal.aborted) {
                     const contentSpan = appState.loadingMsgDiv.querySelector('.content');
                     const prefixSpan = appState.loadingMsgDiv.querySelector('.prefix');
                     if (contentSpan && prefixSpan) {
                         contentSpan.classList.remove('loading-content');
                         prefixSpan.textContent = `${(appState.currentCharacter || 'AI').toUpperCase()}:`;
                         contentSpan.textContent = result.completion;
                     } else {
                         appState.loadingMsgDiv.remove();
                         appendMessage("assistant", result.completion);
                     }
                } else if (appState.loadingMsgDiv) {
                    appState.loadingMsgDiv.remove();
                }
                appState.loadingMsgDiv = null;

                if (result.completion !== undefined && !appState.abortController.signal.aborted) {
                    appState.conversation.push({ role: "assistant", content: result.completion });
                }

                if (appState.currentTokenLimit !== null && appState.currentTokenCount >= appState.currentTokenLimit) {
                    appendMessage("system", `Limite token (${formatTokenCount(appState.currentTokenLimit)}) raggiunto. Reimpostazione automatica del contesto.`);
                    resetConversationState('token limit');
                }

            } catch (error) {
                clearThinkingAnimationAndTimer();

                if (appState.loadingMsgDiv) {
                    appState.loadingMsgDiv.remove();
                    appState.loadingMsgDiv = null;
                }

                if (error.name !== 'AbortError') {
                    appendMessage("error", error.message || "Si √® verificato un errore sconosciuto.");

                    if (error.status === 413 || (error.message && error.message.includes("Token limit reached before processing"))) {
                        appendMessage("system", "Messaggio di input troppo lungo o limite contesto raggiunto. Reimpostazione automatica del contesto.");
                        resetConversationState('input limit');
                    }

                    if (userInput.placeholder !== "Inizializzazione fallita. Ricarica.") {
                      userInput.placeholder = `Errore. Riprova o usa 'reset'. Chiedi all'IA...`;
                    }
                }
                scrollToBottom();

            } finally {
                clearThinkingAnimationAndTimer();
                appState.isWaitingForAI = false;
                appState.abortController = null;
                if (appState.loadingMsgDiv) {
                    appState.loadingMsgDiv.remove();
                    appState.loadingMsgDiv = null;
                }

                if (userInput.placeholder !== "Inizializzazione fallita. Ricarica.") {
                   updateUserInteractionState();
                   setTimeout(() => userInput.focus(), 50);
                }

                 adjustTextareaHeight();
            }
        }

        function handleKeyDown(event) {
            if (event.key === "Enter" && !event.shiftKey && !userInput.disabled) {
                event.preventDefault();
                handleUserInput();
            }
            else if (event.key === "ArrowUp" && !userInput.disabled && userInput.selectionStart === 0 && userInput.selectionEnd === 0) {
                if (appState.commandHistory.length > 0 && appState.historyIndex > 0) {
                    event.preventDefault();
                    appState.historyIndex--;
                    userInput.value = appState.commandHistory[appState.historyIndex];
                    requestAnimationFrame(() => {
                      userInput.setSelectionRange(userInput.value.length, userInput.value.length);
                    });
                    adjustTextareaHeight();
                }
            }
            else if (event.key === "ArrowDown" && !userInput.disabled && userInput.selectionStart === userInput.value.length && userInput.selectionEnd === userInput.value.length) {
                 if (appState.historyIndex < appState.commandHistory.length - 1) {
                    event.preventDefault();
                    appState.historyIndex++;
                    userInput.value = appState.commandHistory[appState.historyIndex];
                     requestAnimationFrame(() => {
                       userInput.setSelectionRange(userInput.value.length, userInput.value.length);
                     });
                    adjustTextareaHeight();
                } else if (appState.historyIndex === appState.commandHistory.length - 1) {
                    event.preventDefault();
                    appState.historyIndex++;
                    userInput.value = "";
                    adjustTextareaHeight();
                }
            }
        }

        async function initializeApp() {
            appendMessage("system", `Sessione avviata: ${new Date().toLocaleString('it-IT')}`);

            updateTokenCounterUI();
            updatePromptUI();
            userInput.placeholder = "Inizializzazione...";
            userInput.disabled = true;
            adjustTextareaHeight();
            scrollToBottom();

            appendMessage("system", "Recupero configurazione...");
            try {
                await callWorkerApi({ type: 'init' });

                appendMessage("system", `Configurazione caricata.`);
                appendMessage("system", `Modalit√†: ${appState.currentCharacter}. Modello: ${appState.currentModel}.`);
                appendMessage("system", `Digita 'help' per i comandi.`);

                userInput.disabled = false;
                appState.isWaitingForAI = false;
                updateUserInteractionState();
                setTimeout(() => userInput.focus(), 0);

            } catch (error) {
                appendMessage("error", `Inizializzazione fallita: ${error.message}`);
                appendMessage("system", "Impossibile caricare la configurazione. Funzionalit√† limitate. Prova a ricaricare la pagina.");
                userInput.placeholder = "Inizializzazione fallita. Ricarica.";
                userInput.disabled = true;
                appState.isWaitingForAI = true;
            } finally {
                 scrollToBottom();
            }
        }

        userInput.addEventListener("keydown", handleKeyDown);
        userInput.addEventListener("input", adjustTextareaHeight);
        terminalDiv.addEventListener('click', (event) => {
            if (event.target === terminalDiv || (terminalDiv.contains(event.target) && event.target.tagName !== 'A' && !event.target.closest('.copy-btn'))) {
                if (window.getSelection().toString() === '' && !appState.isWaitingForAI && !userInput.disabled) {
                   userInput.focus();
                }
            }
        });

        window.addEventListener('resize', adjustTextareaHeight);

        initializeApp();

    </script>	
</body>
</html>

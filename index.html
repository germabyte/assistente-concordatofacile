<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Assistente ConcordatoFacile Plus</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='10 0 100 100'><text y='.9em' font-size='90'>ü§ñ</text></svg>">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
          --md-primary-color: #1976D2; /* Material Blue 700 */
          --md-primary-color-light: #E3F2FD; /* Material Blue 50 */
          --md-accent-color: #651FFF; /* Material Deep Purple A400 */
          --md-accent-color-light: #EDE7F6; /* Material Deep Purple 50 */
          --md-text-primary: #212121;
          --md-text-secondary: #757575;
          --md-text-on-primary: #FFFFFF;
          --md-text-on-accent: #FFFFFF;
          --md-bg-color: #F5F5F5; /* Material Grey 100 */
          --md-surface-color: #FFFFFF;
          --md-border-color: #E0E0E0; /* Material Grey 300 */
          --md-error-color: #D32F2F; /* Material Red 700 */
          --md-error-bg-color: #FFEBEE; /* Material Red 50 */
          --md-system-color: #616161; /* Material Grey 700 */
          --md-system-bg-color: #ECEFF1; /* Material Blue Grey 50 */
          --md-scrollbar-thumb-color: #BDBDBD; /* Material Grey 400 */
          --md-scrollbar-track-color: #EEEEEE; /* Material Grey 200 */

          --font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
          --font-size-base: 16px; /* Material default */
          --font-size-mobile: 15px;
          --line-height: 1.6;

          --padding-base: 16px;
          --padding-mobile: 12px;
          --border-radius-base: 8px; /* Slightly more Material */
          --border-radius-small: 4px;
          --elevation-1: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
          --elevation-2: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
          --elevation-4: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
        }

        *, *::before, *::after {
          box-sizing: border-box;
        }

        html {
          font-size: var(--font-size-base);
        }

        body {
          background-color: var(--md-bg-color);
          color: var(--md-text-primary);
          font-family: var(--font-family);
          margin: 0;
          padding: 0;
          display: flex;
          flex-direction: column;
          height: 100vh;
          height: 100dvh; /* Use dvh for better mobile viewport handling */
          overflow: hidden;
        }

        /* --- Password Overlay Styles --- */
        #passwordOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(33, 33, 33, 0.6); /* Darker overlay */
            display: flex; /* Managed by JS */
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-family: var(--font-family);
        }

        #passwordModal {
            background-color: var(--md-surface-color);
            padding: 24px;
            border-radius: var(--border-radius-base);
            box-shadow: var(--elevation-4);
            text-align: center;
            width: 90%;
            max-width: 400px;
        }

        #passwordModal h2 {
            margin-top: 0;
            margin-bottom: 8px;
            color: var(--md-primary-color);
            font-weight: 500;
        }
        #passwordModal p {
            margin-bottom: 16px;
            color: var(--md-text-secondary);
            font-size: 0.95em;
        }

        #passwordInput {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--md-border-color);
            border-radius: var(--border-radius-small);
            font-size: 1em;
            margin-bottom: 16px;
            background-color: var(--md-surface-color);
            color: var(--md-text-primary);
        }
        #passwordInput:focus {
            border-color: var(--md-primary-color);
            box-shadow: 0 0 0 2px var(--md-primary-color-light);
            outline: none;
        }

        #passwordSubmitButton {
            background-color: var(--md-primary-color);
            color: var(--md-text-on-primary);
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius-small);
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            text-transform: uppercase;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: var(--elevation-1);
        }
        #passwordSubmitButton:hover {
            background-color: #1565C0; /* Darker shade of primary */
            box-shadow: var(--elevation-2);
        }
        #passwordSubmitButton:disabled {
            background-color: var(--md-bg-color);
            color: var(--md-text-secondary);
            opacity: 0.7;
            cursor: not-allowed;
            box-shadow: none;
        }
        #passwordError {
            font-size: 0.9em;
            font-weight: 500;
            margin-top: 10px;
            color: var(--md-error-color); /* Ensure error text color */
            display: none; /* Initially hidden */
        }

        .app-content-hidden {
            display: none !important;
        }
        /* --- End Password Overlay Styles --- */


        #appBar {
            background-color: var(--md-primary-color);
            color: var(--md-text-on-primary);
            padding: calc(var(--padding-base) * 0.75) var(--padding-base);
            font-size: 1.25em;
            font-weight: 500;
            box-shadow: var(--elevation-2);
            z-index: 20;
            display: flex; /* Keep this for original layout */
            align-items: center;
        }
        #appBar h1 {
            margin: 0;
            font-size: inherit;
            font-weight: 500;
        }

        main#terminal {
          flex-grow: 1;
          padding: var(--padding-base);
          overflow-y: auto;
          white-space: pre-wrap;
          word-wrap: break-word;
          line-height: var(--line-height);
        }

        main#terminal::-webkit-scrollbar { width: 8px; }
        main#terminal::-webkit-scrollbar-track { background: var(--md-scrollbar-track-color); }
        main#terminal::-webkit-scrollbar-thumb { background-color: var(--md-scrollbar-thumb-color); border-radius: 4px; }
        main#terminal::-webkit-scrollbar-thumb:hover { background-color: var(--md-text-secondary); }
        main#terminal { scrollbar-width: thin; scrollbar-color: var(--md-scrollbar-thumb-color) var(--md-scrollbar-track-color); }

        footer#inputArea {
          display: flex; /* Keep this for original layout */
          flex-direction: column;
          align-items: stretch;
          background-color: var(--md-surface-color);
          padding: calc(var(--padding-base) * 0.75) var(--padding-base);
          border-top: 1px solid var(--md-border-color);
          box-shadow: var(--elevation-4);
          flex-shrink: 0;
          position: relative;
          z-index: 10;
        }

        #actionsContainer {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        .action-button, .action-select {
            padding: 8px 12px;
            border: 1px solid var(--md-border-color);
            border-radius: var(--border-radius-small);
            background-color: var(--md-surface-color);
            color: var(--md-primary-color);
            font-family: inherit;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px; /* Space between emoji and text */
        }
        .action-button:hover, .action-select:hover {
            background-color: rgba(0,0,0,0.05);
        }
        .action-button:active {
            background-color: rgba(0,0,0,0.1);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }
        .action-button:disabled, .action-select:disabled {
            background-color: var(--md-bg-color);
            color: var(--md-text-secondary);
            opacity: 0.6;
            cursor: not-allowed;
            border-color: var(--md-border-color);
        }
        .action-button:disabled:hover, .action-select:disabled:hover {
             background-color: var(--md-bg-color);
        }

        .action-select {
            flex-grow: 1;
            min-width: 150px;
        }
        .mode-selector-container {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
            color: var(--md-text-secondary);
        }
        .mode-selector-container label {
            white-space: nowrap;
        }

        #fileListContainer {
            width: 100%;
            padding: var(--padding-base);
            border: 2px dashed var(--md-border-color);
            border-radius: var(--border-radius-base);
            background-color: var(--md-surface-color);
            margin-bottom: calc(var(--padding-base) * 0.75);
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: border-color 0.2s ease-in-out;
        }
        #fileListContainer > div {
             display: flex;
             align-items: center;
             gap: 8px;
             overflow: hidden;
             flex-grow: 1;
        }
        #fileListContainer strong {
            font-weight: 500;
            color: var(--md-text-primary);
            flex-shrink: 0;
            white-space: nowrap;
        }
        #fileListDisplay {
            padding: 6px 10px;
            border-radius: var(--border-radius-small);
            border: 1px solid var(--md-border-color);
            white-space: nowrap;
            overflow-x: auto;
            flex-grow: 1;
            max-width: 100%;
            max-height: 45px;
            overflow-y: auto;
            color: var(--md-text-primary);
        }
        #clearFilesBtn {
            font-size: 0.9em;
            padding: 8px 12px;
            background-color: var(--md-error-bg-color);
            color: var(--md-error-color);
            border: 1px solid transparent;
            border-radius: var(--border-radius-small);
            cursor: pointer;
            font-weight: 500;
            flex-shrink: 0;
            margin-left: var(--padding-base);
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        #clearFilesBtn:hover {
            background-color: #f1b0b7;
            border-color: var(--md-error-color);
        }
        #clearFilesBtn:disabled {
            background-color: var(--md-bg-color);
            color: var(--md-text-secondary);
            border-color: var(--md-border-color) !important;
            opacity: 0.6;
            cursor: not-allowed;
        }
        #clearFilesBtn:disabled:hover {
            background-color: var(--md-bg-color);
            border-color: var(--md-border-color) !important;
        }

        #inputControls {
            display: flex;
            width: 100%;
            align-items: flex-end; /* Align items to bottom */
            gap: 8px;
        }

        .emoji-button {
            background-color: transparent;
            border: none;
            color: var(--md-text-secondary);
            padding: 10px; /* Increased padding for touch */
            font-size: 1.6em; /* Emoji size */
            line-height: 1;
            cursor: pointer;
            border-radius: 50%; /* Circular */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, color 0.2s ease;
            flex-shrink: 0; /* Prevent shrinking */
            width: 44px; /* Explicit size */
            height: 44px; /* Explicit size */
        }
        .emoji-button:hover {
            background-color: rgba(0,0,0,0.08);
            color: var(--md-primary-color);
        }
        .emoji-button:disabled {
            color: var(--md-border-color);
            cursor: not-allowed;
            background-color: transparent !important; /* Ensure no hover style on disabled */
        }

        #userInput {
          flex-grow: 1;
          background-color: var(--md-surface-color);
          border: 1px solid var(--md-border-color);
          border-radius: var(--border-radius-base);
          outline: none;
          color: var(--md-text-primary);
          font-family: var(--font-family);
          font-size: inherit;
          line-height: var(--line-height);
          padding: 10px 12px;
          caret-color: var(--md-primary-color);
          resize: none;
          overflow-y: hidden;
          min-height: calc(var(--line-height) * 1em + 20px + 2px); /* padding + border */
        }
        #userInput:focus {
            border-color: var(--md-primary-color);
            box-shadow: 0 0 0 2px var(--md-primary-color-light);
        }
        #userInput::placeholder { color: var(--md-text-secondary); opacity: 0.7; }
        #userInput:disabled { cursor: not-allowed; background-color: var(--md-bg-color); opacity: 0.7; }

        #prompt { display: none; }


        .message {
          position: relative;
          margin-bottom: calc(var(--padding-base) * 0.75);
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          padding: calc(var(--padding-base) * 0.75) var(--padding-base);
          border-radius: var(--border-radius-base);
          max-width: 85%;
          box-shadow: var(--elevation-1);
        }

        .prefix {
          font-weight: 500; /* Material medium weight */
          flex-shrink: 0;
          margin-bottom: 0.3em;
          user-select: none;
          white-space: pre;
          font-size: 0.85em;
          opacity: 0.9;
        }
        .content { flex-grow: 1; word-break: break-word; }

        .user { background-color: var(--md-primary-color-light); align-self: flex-end; }
        .user .prefix { color: var(--md-primary-color); }
        .user .content { color: var(--md-text-primary); }

        .assistant { background-color: var(--md-accent-color-light); align-self: flex-start; }
        .assistant .prefix { color: var(--md-accent-color); }
        .assistant .content { color: var(--md-text-primary); }

        .system { background-color: var(--md-system-bg-color); font-size: 0.9em; align-self: center; max-width: 90%; text-align: center; }
        .system .prefix { color: var(--md-system-color); }
        .system .content { color: var(--md-system-color); opacity: 0.9; }

        .system.help-output {
            text-align: left; align-self: flex-start; max-width: 95%;
            background-color: var(--md-system-bg-color);
        }
        .system.help-output .prefix,
        .system.help-output .content { color: var(--md-system-color); opacity: 1; }


        .error { background-color: var(--md-error-bg-color); align-self: center; text-align: center; max-width: 90%; border: 1px solid var(--md-error-color); }
        .error .prefix { color: var(--md-error-color); }
        .error .content { color: var(--md-error-color); font-weight: 500; }


        .loading-content { display: inline-flex; align-items: baseline; }
        .thinking-timer-span { margin-left: 8px; font-size: 0.9em; opacity: 0.8; color: var(--md-system-color); white-space: nowrap; }

        .copy-btn {
          position: absolute;
          top: 8px; right: 8px;
          background: rgba(0,0,0,0.05);
          color: var(--md-text-secondary);
          padding: 6px;
          border-radius: 50%;
          font-size: 1.1em; /* For emoji */
          cursor: pointer;
          opacity: 0;
          user-select: none;
          transition: opacity 0.15s ease-in, background-color 0.15s ease-in, color 0.15s ease-in;
          line-height: 1;
          border: none;
          display: flex; align-items: center; justify-content: center;
          width: 32px; height: 32px;
        }
        .message:hover .copy-btn { opacity: 0.6; }
        .copy-btn:hover { opacity: 1; background: rgba(0,0,0,0.1); color: var(--md-primary-color); }
        .copy-btn:focus { outline: none; }

        .floatingToggle, #tokenCounter {
          position: fixed;
          background-color: var(--md-surface-color);
          color: var(--md-text-secondary);
          padding: 8px 14px;
          border: 1px solid var(--md-border-color);
          border-radius: 18px; /* Pill shape */
          z-index: 1000;
          font-family: var(--font-family);
          font-size: 0.85em;
          font-weight: 500;
          box-shadow: var(--elevation-2);
          transition: bottom 0.2s ease-out, background-color 0.2s ease;
          user-select: none;
        }
        .floatingToggle {
          left: 20px;
          cursor: pointer;
        }
        .floatingToggle:hover {
            background-color: var(--md-bg-color);
        }
        #tokenCounter {
          right: 20px;
        }

        @media (max-width: 768px) {
          html { font-size: var(--font-size-mobile); }
          #appBar { padding: calc(var(--padding-mobile) * 0.8) var(--padding-mobile); font-size: 1.15em; }
          main#terminal { padding: var(--padding-mobile); }
          footer#inputArea { padding: calc(var(--padding-mobile) * 0.8) var(--padding-mobile); }
          .message { margin-bottom: calc(var(--padding-mobile) * 1.1); padding: calc(var(--padding-mobile) * 0.9) var(--padding-mobile); }
          .message { max-width: 95%; }
          .system, .error { max-width: 98%; }
          main#terminal::-webkit-scrollbar { width: 6px; }
          .floatingToggle, #tokenCounter { font-size: 0.8em; padding: 6px 10px; }
          .floatingToggle { left: 15px; }
          #tokenCounter { right: 15px; }
          .emoji-button { font-size: 1.5em; padding: 8px; width: 40px; height: 40px; }
          #userInput { padding: 8px 10px; min-height: calc(var(--line-height) * 1em + 16px + 2px); }
          #actionsContainer { flex-direction: column; align-items: stretch; gap: 6px; }
          .action-select { min-width: 0; }

          #fileListContainer {
              padding: var(--padding-mobile);
              flex-direction: column;
              align-items: stretch;
              gap: 8px;
          }
          #fileListContainer > div { gap: 6px; }
          #clearFilesBtn { align-self: flex-end; margin-left: 0; margin-top: 4px; }
        }
    </style>
</head>
<body>
    <!-- Password Overlay -->
    <div id="passwordOverlay" style="display: none;"> <!-- Initially hidden, JS will show if needed -->
        <div id="passwordModal">
            <h2>Accesso Protetto</h2>
            <p>Inserisci la password per sbloccare l'assistente:</p>
            <input type="password" id="passwordInput" placeholder="Password" autofocus>
            <button id="passwordSubmitButton">Accedi</button>
            <p id="passwordError" style="color: var(--md-error-color); display: none; margin-top: 10px;"></p>
        </div>
    </div>

    <!-- Main App Content: add app-content-hidden class -->
    <header id="appBar" class="app-content-hidden">
        <h1>ü§ñ Assistente ConcordatoFacile Plus</h1>
    </header>

    <main id="terminal" class="app-content-hidden"></main>

    <div id="tokenCounter" class="app-content-hidden">Token: 0</div>
    <div id="scrollToggle" class="floatingToggle app-content-hidden">üîÑ Scroll: ON</div>

    <footer id="inputArea" class="app-content-hidden">
        <div id="actionsContainer">
            <div class="mode-selector-container">
                <label for="modeSelector">üë§ Modalit√†:</label>
                <select id="modeSelector" class="action-select" title="Seleziona modalit√† IA"></select>
            </div>
            <button id="helpButton" class="action-button" title="Mostra aiuto">‚ùì Aiuto</button>
            <button id="resetButton" class="action-button" title="Reimposta chat e contesto">‚ôªÔ∏è Reset</button>
            <button id="stopButton" class="action-button" title="Interrompi risposta IA" style="display: none; background-color: var(--md-error-bg-color); color: var(--md-error-color); border-color: var(--md-error-color);">üõë Stop</button>
        </div>

        <div id="fileListContainer" style="display: none;">
            <div>
                <strong>File allegati:</strong>
                <span id="fileListDisplay">Nessuno</span>
            </div>
            <button id="clearFilesBtn" title="Rimuovi tutti i file" style="display: none;">üóëÔ∏è Rimuovi Tutti</button>
        </div>

        <div id="inputControls">
            <button id="attachFilesBtn" class="emoji-button" title="Allega file (max 15)">üìé</button>
            <input type="file" id="fileUploader" multiple accept=".pdf,.png,.jpg,.jpeg,.webp" style="display:none;">
            <span id="prompt">></span>
            <textarea id="userInput" rows="1" placeholder="Inizializzazione..." autofocus autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" disabled></textarea>
            <button id="sendButton" class="emoji-button" title="Invia messaggio">‚û°Ô∏è</button>
        </div>
    </footer>

    <script>
        const WORKER_URL = "https://germabyte-assistente-80.deno.dev/";

        // --- Elements for Password Overlay ---
        const passwordOverlay = document.getElementById('passwordOverlay');
        const passwordInput = document.getElementById('passwordInput');
        const passwordSubmitButton = document.getElementById('passwordSubmitButton');
        const passwordError = document.getElementById('passwordError');
        const AUTH_SESSION_KEY = 'appAuthenticated_assistente_cf_plus_v1'; // Specific key, v1 for potential future changes

        // --- Main App Elements (cache them for show/hide) ---
        const mainAppContentElements = [
            document.getElementById('appBar'),
            document.getElementById('terminal'),
            document.getElementById('tokenCounter'),
            document.getElementById('scrollToggle'),
            document.getElementById('inputArea')
        ].filter(el => el !== null); // Filter out nulls if any ID is mistyped


        // --- Existing App Elements ---
        const terminalDiv = document.getElementById("terminal");
        const userInput = document.getElementById("userInput");
        const tokenCounterDiv = document.getElementById("tokenCounter");
        const scrollToggleDiv = document.getElementById("scrollToggle");
        const promptSpan = document.getElementById("prompt");

        const attachFilesBtn = document.getElementById("attachFilesBtn");
        const fileUploader = document.getElementById("fileUploader");
        const fileListContainer = document.getElementById("fileListContainer");
        const fileListDisplay = document.getElementById("fileListDisplay");
        const clearFilesBtn = document.getElementById("clearFilesBtn");

        const sendButton = document.getElementById("sendButton");
        const helpButton = document.getElementById("helpButton");
        const resetButton = document.getElementById("resetButton");
        const stopButton = document.getElementById("stopButton");
        const modeSelector = document.getElementById("modeSelector");


        const COMMAND_INFO = [
          { name: "help", desc: "help - Mostra questo messaggio di aiuto." },
          { name: "reset", desc: "reset - Reimposta il contesto della chat." },
          { name: "imposta modalit√†", desc: "imposta modalit√† <nome> - Cambia la modalit√† IA (es. fideiussione, estrazione-dati)." },
          { name: "stop", desc: "stop - Interrompe la risposta corrente dell'IA." }
        ];
        const MAX_FILES = 15;
        const ALLOWED_MIMETYPES = ['application/pdf', 'image/png', 'image/jpeg', 'image/webp'];

        let autoScrollEnabled = true;
        const appState = {
            conversation: [],
            commandHistory: [],
            historyIndex: -1,
            isWaitingForAI: false,
            currentCharacter: null,
            currentModel: null,
            availableCharacters: [],
            currentTokenCount: 0,
            currentTokenLimit: null,
            thinkingIntervalId: null,
            timerIntervalId: null,
            thinkingStartTime: null,
            abortController: null,
            loadingMsgDiv: null,
            uploadedFiles: [],
        };

        // --- UI Control Functions for Auth ---
        function showMainAppUI() {
            mainAppContentElements.forEach(el => {
                if (el) {
                    el.classList.remove('app-content-hidden');
                    // Restore original display styles if '.app-content-hidden' used 'display: none !important'
                    // For flex containers, ensure their display style is set correctly
                    if (el.id === 'appBar' || el.id === 'inputArea' || el.id === 'actionsContainer' || el.id === 'inputControls' || el.id === 'fileListContainer') {
                        el.style.display = 'flex'; // These are known flex containers or children of flex
                    } else if (el.id === 'terminal' || el.id === 'tokenCounter' || el.id === 'scrollToggle') {
                        el.style.display = 'block'; // Or their original display type
                    } else {
                         el.style.display = ''; // Fallback to default CSS computed display
                    }
                }
            });
            if (passwordOverlay) passwordOverlay.style.display = 'none';

            // Ensure specific flex containers are indeed flex if needed, as `app-content-hidden` might override
            if (document.getElementById('appBar')) document.getElementById('appBar').style.display = 'flex';
            if (document.getElementById('inputArea')) document.getElementById('inputArea').style.display = 'flex';
            if (document.getElementById('actionsContainer')) document.getElementById('actionsContainer').style.display = 'flex';
            if (document.getElementById('inputControls')) document.getElementById('inputControls').style.display = 'flex';
            // fileListContainer's display is managed by updateInteractiveElementsUI

            adjustTextareaHeight(); // Recalculate layout-dependent styles
            if (userInput && !userInput.disabled) {
                setTimeout(() => userInput.focus(), 100); // Focus after UI is surely visible
            }
        }

        function showPasswordScreenUI() {
            mainAppContentElements.forEach(el => {
                if (el) {
                    el.classList.add('app-content-hidden');
                    el.style.display = 'none'; // Ensure it's hidden
                }
            });
            if (passwordOverlay) {
                passwordOverlay.style.display = 'flex';
                setTimeout(() => {
                    if(passwordInput) passwordInput.focus();
                }, 100);
            }
        }

        async function attemptAuthentication() {
            const password = passwordInput.value;
            if (!password) {
                passwordError.textContent = "La password non pu√≤ essere vuota.";
                passwordError.style.display = 'block';
                return;
            }

            passwordSubmitButton.disabled = true;
            passwordError.style.display = 'none';

            try {
                const response = await callWorkerApi({ type: 'auth', password: password }); // No signal needed for auth

                if (response.authenticated) {
                    sessionStorage.setItem(AUTH_SESSION_KEY, 'true');
                    showMainAppUI();
                    if (response.message && terminalDiv) { // Display server message if any (e.g. "password not configured")
                        appendMessage("system", response.message);
                    }
                    initializeApp(); // Initialize the main application logic AFTER authentication
                } else {
                    passwordError.textContent = response.error || "Password errata. Riprova.";
                    passwordError.style.display = 'block';
                    passwordInput.value = '';
                    passwordInput.focus();
                }
            } catch (error) {
                console.error("Errore durante il processo di autenticazione:", error);
                let displayError = "Errore di autenticazione. Riprova pi√π tardi.";
                if (error && error.message && !error.message.toLowerCase().includes('failed to fetch')) {
                     // Use error.message only if it's from our explicit backend error structure
                    if (error.data && error.data.error) displayError = error.data.error;
                    else displayError = error.message;
                } else if (error && error.message && error.message.toLowerCase().includes('failed to fetch')) {
                    displayError = "Errore di rete. Impossibile contattare il server.";
                }
                passwordError.textContent = displayError;
                passwordError.style.display = 'block';
            } finally {
                passwordSubmitButton.disabled = false;
            }
        }


        // --- Existing App Functions (slightly reordered for clarity) ---
        scrollToggleDiv.addEventListener("click", () => {
          autoScrollEnabled = !autoScrollEnabled;
          scrollToggleDiv.textContent = autoScrollEnabled
            ? "üîÑ Scroll: ON"
            : "üö´ Scroll: OFF";
        });

        function formatTokenCount(num) {
            if (num === undefined || num === null) return '?';
            if (num < 1000) return num.toString();
            return (num / 1000).toFixed(1).replace(/\.0$/, '') + "k";
        }

        function appendMessage(role, text, isLoading = false, extraClass = null, overridePrefix = null) {
            if (!terminalDiv) return null; // Guard against terminalDiv not being ready
            const msgDiv = document.createElement("div");
            msgDiv.classList.add("message", role);
            if (extraClass) msgDiv.classList.add(extraClass);

            const prefixSpan = document.createElement("span");
            prefixSpan.classList.add("prefix");
            const contentSpan = document.createElement("span");
            contentSpan.classList.add("content");

            switch(role) {
                case 'user': prefixSpan.textContent = "TU:"; contentSpan.textContent = text; break;
                case 'assistant':
                    prefixSpan.textContent = "IA:";
                    if (isLoading) {
                        contentSpan.classList.add("loading-content");
                        contentSpan.innerHTML = `<span class="thinking-dots-span">Sto pensando.</span><span class="thinking-timer-span">(0.0s)</span>`;
                    } else { contentSpan.textContent = text; }
                    break;
                case 'system': prefixSpan.textContent = "SISTEMA:"; contentSpan.textContent = text; break;
                case 'error': prefixSpan.textContent = "ERRORE!"; contentSpan.textContent = text; break;
                default: prefixSpan.textContent = "???:"; contentSpan.textContent = text;
            }
            msgDiv.appendChild(prefixSpan);
            msgDiv.appendChild(contentSpan);

            if ((role === 'user' || role === 'assistant') && !isLoading) {
                const copyBtn = document.createElement("button");
                copyBtn.classList.add("copy-btn"); copyBtn.setAttribute("title", "Copia messaggio"); copyBtn.textContent = "üìã";
                copyBtn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  const txtToCopy = contentSpan.textContent || "";
                  navigator.clipboard.writeText(txtToCopy).then(() => {
                    copyBtn.textContent = "‚úÖ"; setTimeout(() => (copyBtn.textContent = "üìã"), 1500);
                  }).catch(() => {
                    copyBtn.textContent = "‚ùå"; setTimeout(() => (copyBtn.textContent = "üìã"), 1500);
                  });
                });
                msgDiv.appendChild(copyBtn);
            }
            terminalDiv.appendChild(msgDiv);
            scrollToBottom();
            return msgDiv;
        }

        function scrollToBottom() {
          if (!autoScrollEnabled || !terminalDiv) return;
          requestAnimationFrame(() => {
            terminalDiv.scrollTo({ top: terminalDiv.scrollHeight, behavior: 'smooth' });
          });
        }

        function adjustTextareaHeight() {
            if (!userInput) return;
            userInput.style.height = 'auto';
            let newHeight = userInput.scrollHeight;
            const maxHeight = 180;
            if (newHeight > maxHeight) {
                newHeight = maxHeight;
                userInput.style.overflowY = 'auto';
            } else {
                userInput.style.overflowY = 'hidden';
            }
            userInput.style.height = newHeight + 'px';

            const inputAreaElement = document.getElementById('inputArea');
            if (inputAreaElement && terminalDiv) { // Check terminalDiv exists
                terminalDiv.style.paddingBottom = `${inputAreaElement.offsetHeight + 30}px`;
            }

            const inputAreaHeight = inputAreaElement?.offsetHeight || 70;
            const baseOffset = window.innerWidth <= 768 ? 10 : 15;
            const newBottom = `${inputAreaHeight + baseOffset}px`;

            if(tokenCounterDiv) tokenCounterDiv.style.bottom = newBottom;
            if(scrollToggleDiv) scrollToggleDiv.style.bottom = newBottom;
        }

        function updateTokenCounterUI() {
            if (!tokenCounterDiv) return;
            const countStr = formatTokenCount(appState.currentTokenCount);
            const limitStr = formatTokenCount(appState.currentTokenLimit);
            tokenCounterDiv.textContent = `Token: ${countStr}${appState.currentTokenLimit !== null ? '/' + limitStr : ''}`;
        }

        function populateModeSelector() {
            if (!modeSelector) return;
            modeSelector.innerHTML = '';
            const sortedCharacters = [...(appState.availableCharacters || [])].sort((a, b) => a.localeCompare(b));

            if (sortedCharacters.length > 0) {
                sortedCharacters.forEach(char => {
                    const option = document.createElement('option');
                    option.value = char;
                    option.textContent = char.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
                    if (char === appState.currentCharacter) option.selected = true;
                    modeSelector.appendChild(option);
                });
                modeSelector.disabled = false;
            } else {
                const option = document.createElement('option');
                option.textContent = "Nessuna modalit√† disponibile"; option.disabled = true;
                modeSelector.appendChild(option);
                modeSelector.disabled = true;
            }
        }

        function updateInteractiveElementsUI() {
            if (!attachFilesBtn || !fileListContainer || !userInput || !fileListDisplay || !clearFilesBtn || !modeSelector) return;

            const isEstrazioneDati = appState.currentCharacter === 'estrazione-dati';
            attachFilesBtn.style.display = isEstrazioneDati ? 'inline-flex' : 'none';

            if (isEstrazioneDati) {
                fileListContainer.style.display = 'flex';
                userInput.placeholder = appState.uploadedFiles.length > 0
                    ? "Premi Invio o ‚û°Ô∏è per estrarre, o aggiungi una nota..."
                    : "Allega file (PDF, PNG, JPG) per l'estrazione...";
                if (appState.uploadedFiles.length > 0) {
                    fileListDisplay.style.fontStyle = 'normal';
                    fileListDisplay.style.color = 'var(--md-text-primary)';
                    clearFilesBtn.style.display = 'inline-block';
                } else {
                    fileListDisplay.style.fontStyle = 'italic';
                    fileListDisplay.style.color = 'var(--md-text-secondary)';
                    clearFilesBtn.style.display = 'none';
                }
            } else {
                fileListContainer.style.display = 'none';
                clearFilesBtn.style.display = 'none';
                userInput.placeholder = `Chiedi all'IA (${appState.currentCharacter ? appState.currentCharacter.replace(/-/g, ' ') : '...'})`;
            }
            if (modeSelector.value !== appState.currentCharacter) modeSelector.value = appState.currentCharacter;
            adjustTextareaHeight();
        }

        function updateUserInteractionState() {
            if (!userInput || !sendButton || !attachFilesBtn || !modeSelector || !helpButton || !resetButton || !clearFilesBtn || !stopButton) return;

             const isDisabledByInitFailure = userInput.placeholder === "Inizializzazione fallita. Ricarica.";
             const effectivelyWaiting = appState.isWaitingForAI || isDisabledByInitFailure;

             userInput.disabled = effectivelyWaiting;
             sendButton.disabled = effectivelyWaiting;
             attachFilesBtn.disabled = effectivelyWaiting || appState.currentCharacter !== 'estrazione-dati';
             modeSelector.disabled = effectivelyWaiting;
             helpButton.disabled = effectivelyWaiting;
             resetButton.disabled = effectivelyWaiting;
             clearFilesBtn.disabled = effectivelyWaiting || appState.uploadedFiles.length === 0;
             stopButton.style.display = appState.isWaitingForAI && !isDisabledByInitFailure ? 'inline-flex' : 'none';

             if (appState.isWaitingForAI && !isDisabledByInitFailure) {
                 userInput.placeholder = `IA sta rispondendo... (puoi usare üõë Stop)`;
             } else if (isDisabledByInitFailure) {
                 // Placeholder already set
             } else if (!appState.currentCharacter) {
                 userInput.placeholder = "Caricamento configurazione...";
             } else {
                 updateInteractiveElementsUI();
             }
        }

        function startThinkingAnimationAndTimer() {
            if (!appState.loadingMsgDiv) return;
            const dotsSpan = appState.loadingMsgDiv.querySelector('.thinking-dots-span');
            const timerSpan = appState.loadingMsgDiv.querySelector('.thinking-timer-span');
            if (!dotsSpan || !timerSpan) return;
            let dotCount = 1;
            appState.thinkingIntervalId = setInterval(() => {
                dotCount = (dotCount % 3) + 1;
                dotsSpan.textContent = "Sto pensando" + ".".repeat(dotCount);
            }, 400);
            appState.thinkingStartTime = Date.now();
            timerSpan.textContent = `(0.0s)`;
            appState.timerIntervalId = setInterval(() => {
                const elapsedMilliseconds = Date.now() - appState.thinkingStartTime;
                const elapsedSecondsFormatted = (elapsedMilliseconds / 1000).toFixed(1);
                timerSpan.textContent = `(${elapsedSecondsFormatted}s)`;
            }, 100);
        }

        function clearThinkingAnimationAndTimer() {
            if (appState.thinkingIntervalId) clearInterval(appState.thinkingIntervalId);
            if (appState.timerIntervalId) clearInterval(appState.timerIntervalId);
            appState.thinkingIntervalId = null; appState.timerIntervalId = null; appState.thinkingStartTime = null;
            if (appState.loadingMsgDiv) {
                const contentSpan = appState.loadingMsgDiv.querySelector('.content');
                if (contentSpan) contentSpan.classList.remove('loading-content');
            }
        }

        function updateStateFromWorkerResponse(data) {
            if (data.activeCharacter) appState.currentCharacter = data.activeCharacter;
            if (data.activeModel) appState.currentModel = data.activeModel;
            if (data.availableCharacters) {
                appState.availableCharacters = data.availableCharacters;
                populateModeSelector();
            }
            if (typeof data.tokenCount === 'number') appState.currentTokenCount = data.tokenCount;
            if (typeof data.tokenLimit === 'number') appState.currentTokenLimit = data.tokenLimit;
            updateTokenCounterUI();
            updateInteractiveElementsUI();
        }

        function clearUploadedFiles() {
            appState.uploadedFiles = [];
            if (fileUploader) fileUploader.value = null;
            if (fileListDisplay) fileListDisplay.textContent = "Nessuno";
            updateInteractiveElementsUI();
            updateUserInteractionState();
        }

        function resetConversationState(reason) {
            const reasonMap = { 'user command': 'comando utente', 'character change': 'cambio modalit√†',
                                'token limit': 'limite token', 'input limit': 'limite input', 'button action': 'azione utente' };
            const italianReason = reasonMap[reason] || reason;
            appState.conversation = []; appState.currentTokenCount = 0;
            clearUploadedFiles();
            updateTokenCounterUI();
            appendMessage("system", `Contesto chat reimpostato (${italianReason}). Nuova conversazione avviata.`);
            updateUserInteractionState();
            scrollToBottom();
        }

        async function callWorkerApi(payload, signal) { // Signal is optional
            let response;
            try {
                response = await fetch(WORKER_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                    signal // Pass signal if provided
                });
                const data = await response.json(); // Always try to parse JSON for error details

                if (!response.ok) {
                    let errorMsg = `Errore API (${response.status})`;
                    errorMsg += `: ${data?.error || response.statusText || 'Errore sconosciuto dal server'}`;
                    if (data?.details) console.error("Dettagli Errore API:", data.details);
                    console.error("Risposta Errore API Completa:", data);

                    // Preserve some state if possible from error response
                    if (data?.availableCharacters) appState.availableCharacters = data.availableCharacters;
                    if (typeof data?.tokenLimit === 'number') appState.currentTokenLimit = data.tokenLimit;
                    if (typeof data?.tokenCount === 'number') appState.currentTokenCount = data.tokenCount;
                    updateTokenCounterUI(); // Update UI with any partial state received

                    const error = new Error(errorMsg);
                    error.status = response.status;
                    error.data = data; // Attach full error data
                    throw error;
                }
                // For non-auth calls, update state if it's a successful AI/init response
                if (payload.type !== 'auth' && data) {
                   updateStateFromWorkerResponse(data);
                }
                return data; // Return full data for auth or AI/init
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log("Fetch interrotto dall'utente.");
                    throw error; // Re-throw for specific handling upstream
                }
                console.error("Errore Fetch/API:", error);
                if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                     const networkError = new Error("Errore di rete. Impossibile raggiungere il worker API.");
                     networkError.status = 0; // Indicate network error
                     networkError.data = { error: networkError.message }; // Standardize error structure
                     throw networkError;
                }
                // If error already has a 'data' property (from the !response.ok block), preserve it
                if (!error.data) {
                    error.data = { error: error.message || "Errore sconosciuto durante la chiamata API." };
                }
                throw error; // Re-throw for upstream handling
            }
        }

        async function handleUserInput() {
            if (!userInput) return;
            const inputText = userInput.value.trim();

            if (appState.currentCharacter !== 'estrazione-dati' && inputText === "") {
                userInput.value = ""; adjustTextareaHeight(); return;
            }
            if (appState.isWaitingForAI) {
                if (inputText.toLowerCase() === 'stop') {
                    appendMessage("user", inputText); userInput.value = ""; adjustTextareaHeight();
                    if (appState.abortController) appState.abortController.abort();
                    else appendMessage("error", "Impossibile fermare: Nessun processo IA attivo.");
                } else if (inputText !== "") {
                    appendMessage("user", inputText); userInput.value = ""; adjustTextareaHeight();
                    appendMessage("system", "L'IA √® occupata. Il tuo messaggio √® ignorato. Usa üõë Stop.");
                }
                scrollToBottom(); return;
            }

            const currentInputTextForHistory = (appState.currentCharacter === 'estrazione-dati' && appState.uploadedFiles.length > 0)
                ? (inputText || `[${appState.uploadedFiles.length} file allegati]`) : inputText;
            if (currentInputTextForHistory && (appState.commandHistory.length === 0 || appState.commandHistory[appState.commandHistory.length - 1] !== currentInputTextForHistory)) {
                appState.commandHistory.push(currentInputTextForHistory);
            }
            appState.historyIndex = appState.commandHistory.length;

            const commandArgs = inputText.toLowerCase().split(/\s+/);
            const command = commandArgs[0];
            const originalArgs = inputText.split(/\s+/);

            if (command === 'reset') {
                appendMessage("user", inputText); userInput.value = ""; adjustTextareaHeight();
                resetConversationState('user command'); return;
            }
            if (command === 'help') {
                appendMessage("user", inputText); userInput.value = ""; adjustTextareaHeight();
                const commandsSorted = [...COMMAND_INFO].sort((a,b)=>a.name.localeCompare(b.name,{sensitivity:"base"}));
                let helpOutput = "COMANDI DISPONIBILI:\n" + commandsSorted.map(c=>`  ${c.desc}`).join("\n");
                helpOutput += "\n\nMODALIT√Ä DISPONIBILI:\n  " + (appState.availableCharacters.length ? appState.availableCharacters.join(', ') : 'Nessuna caricata');
                helpOutput += `\n\nSTATO ATTUALE:\n  Modalit√†: ${appState.currentCharacter || 'Non impostata'}\n`;
                helpOutput += "\nCOME CHATTARE:\n  ‚Ä¢ Scrivi e premi Invio o ‚û°Ô∏è.\n  ‚Ä¢ Estrazione-dati: allega file (üìé), poi invia.\n";
                appendMessage("system", helpOutput, false, "help-output"); scrollToBottom(); return;
            }
            if (command === 'imposta' && originalArgs.length >= 2 && originalArgs[1].toLowerCase() === 'modalit√†') {
                appendMessage("user", inputText); userInput.value = ""; adjustTextareaHeight();
                if (originalArgs.length < 3) { appendMessage("error", "Utilizzo: imposta modalit√† <nome>"); return; }
                const settingValue = originalArgs.slice(2).join(' ');
                const characterNameLower = settingValue.toLowerCase();
                const foundCharacter = appState.availableCharacters.find(c => c.toLowerCase() === characterNameLower);
                if (foundCharacter) {
                     if (appState.currentCharacter !== foundCharacter) {
                         appState.currentCharacter = foundCharacter; modeSelector.value = foundCharacter;
                         appendMessage("system", `Modalit√† impostata su: ${foundCharacter}.`);
                         resetConversationState('character change');
                     } else appendMessage("system", `La modalit√† √® gi√†: ${foundCharacter}.`);
                } else {
                     const availableModesString = appState.availableCharacters.length ? appState.availableCharacters.join(', ') : 'Nessuna';
                     appendMessage("error", `Modalit√† '${settingValue}' non trovata. Disponibili: ${availableModesString}`);
                }
                scrollToBottom(); return;
            }

            let userMessageForConversation, displayUserTextInChat;
            if (appState.currentCharacter === 'estrazione-dati') {
                if (appState.uploadedFiles.length === 0 && !inputText) {
                    appendMessage("system", "Per estrazione dati, allega file (üìé) o fornisci query testuale.");
                    userInput.value = ""; adjustTextareaHeight(); return;
                }
                if (appState.uploadedFiles.length === 0 && inputText) {
                    displayUserTextInChat = inputText;
                    userMessageForConversation = { role: "user", content: inputText };
                } else {
                    displayUserTextInChat = inputText || `Estrazione dati da ${appState.uploadedFiles.length} file.`;
                    const userMessageContentArray = [{ type: "text", text: inputText || "Estrai i dati dai documenti." }];
                    appState.uploadedFiles.forEach(file => {
                        if (file.type.startsWith('image/')) userMessageContentArray.push({ type: "image_url", image_url: { url: file.dataUrl } });
                        else if (file.type === 'application/pdf') userMessageContentArray.push({ type: "file", file: { filename: file.name, file_data: file.dataUrl } });
                    });
                    userMessageForConversation = { role: "user", content: userMessageContentArray };
                }
            } else {
                if (inputText === "") return;
                displayUserTextInChat = inputText;
                userMessageForConversation = { role: "user", content: inputText };
            }

            appendMessage("user", displayUserTextInChat);
            appState.conversation.push(userMessageForConversation);
            userInput.value = ""; adjustTextareaHeight(); scrollToBottom();

            appState.isWaitingForAI = true; updateUserInteractionState();
            appState.loadingMsgDiv = appendMessage("assistant", "", true);
            startThinkingAnimationAndTimer();
            appState.abortController = new AbortController();

            try {
                const payload = { messages: appState.conversation, character: appState.currentCharacter, model: appState.currentModel };
                const result = await callWorkerApi(payload, appState.abortController.signal); // Signal is passed here
                clearThinkingAnimationAndTimer();

                if (appState.loadingMsgDiv) {
                     const contentSpan = appState.loadingMsgDiv.querySelector('.content');
                     const prefixSpan = appState.loadingMsgDiv.querySelector('.prefix');
                     if (contentSpan && prefixSpan) {
                         contentSpan.classList.remove('loading-content'); prefixSpan.textContent = "IA:";
                         contentSpan.textContent = result.completion;
                     } else {
                         if(appState.loadingMsgDiv) appState.loadingMsgDiv.remove();
                         appendMessage("assistant", result.completion);
                     }
                }
                appState.loadingMsgDiv = null;

                if (result.completion !== undefined) {
                    appState.conversation.push({ role: "assistant", content: result.completion });
                    if (appState.currentCharacter === 'estrazione-dati' && appState.uploadedFiles.length > 0) clearUploadedFiles();
                }
                if (appState.currentTokenLimit !== null && appState.currentTokenCount >= appState.currentTokenLimit) {
                    appendMessage("system", `Limite token (${formatTokenCount(appState.currentTokenLimit)}) raggiunto. Reset automatico.`);
                    resetConversationState('token limit');
                }
            } catch (error) {
                clearThinkingAnimationAndTimer();
                if (appState.loadingMsgDiv) { appState.loadingMsgDiv.remove(); appState.loadingMsgDiv = null; }

                if (error.name === 'AbortError') {
                    appendMessage("system", "Risposta IA interrotta dall'utente.");
                } else {
                    // Use error.data.error if available (from structured backend error), else error.message
                    const errorMessageToDisplay = (error.data && error.data.error) ? error.data.error : (error.message || "Errore sconosciuto.");
                    appendMessage("error", errorMessageToDisplay);
                    if (error.status === 413 || (errorMessageToDisplay && errorMessageToDisplay.includes("Token limit reached"))) {
                        appendMessage("system", "Input troppo lungo o limite contesto. Reset automatico.");
                        resetConversationState('input limit');
                    }
                }
                scrollToBottom();
            } finally {
                clearThinkingAnimationAndTimer();
                appState.isWaitingForAI = false; appState.abortController = null;
                if (appState.loadingMsgDiv) { appState.loadingMsgDiv.remove(); appState.loadingMsgDiv = null; }
                if (userInput && userInput.placeholder !== "Inizializzazione fallita. Ricarica.") {
                   updateUserInteractionState();
                   setTimeout(() => userInput.focus(), 50);
                }
            }
        }

        function handleKeyDown(event) {
            if (!userInput || userInput.disabled) return;
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault(); handleUserInput();
            }
            else if (event.key === "ArrowUp" && userInput.selectionStart === 0 && userInput.selectionEnd === 0) {
                if (appState.commandHistory.length > 0 && appState.historyIndex > 0) {
                    event.preventDefault(); appState.historyIndex--;
                    userInput.value = appState.commandHistory[appState.historyIndex];
                    requestAnimationFrame(() => { userInput.setSelectionRange(userInput.value.length, userInput.value.length); });
                    adjustTextareaHeight();
                }
            }
            else if (event.key === "ArrowDown" && userInput.selectionStart === userInput.value.length && userInput.selectionEnd === userInput.value.length) {
                 if (appState.historyIndex < appState.commandHistory.length - 1) {
                    event.preventDefault(); appState.historyIndex++;
                    userInput.value = appState.commandHistory[appState.historyIndex];
                    requestAnimationFrame(() => { userInput.setSelectionRange(userInput.value.length, userInput.value.length); });
                    adjustTextareaHeight();
                } else if (appState.historyIndex === appState.commandHistory.length - 1) {
                    event.preventDefault(); appState.historyIndex++; userInput.value = ""; adjustTextareaHeight();
                }
            }
        }

        // --- Event Listeners Setup (should be done after DOM is ready or elements are defined) ---
        // Listeners for auth screen are set in DOMContentLoaded
        // Listeners for main app can be set here or within initializeApp if elements are not ready globally

        if (attachFilesBtn) attachFilesBtn.addEventListener('click', () => fileUploader.click());
        if (clearFilesBtn) clearFilesBtn.addEventListener('click', () => {
            if (appState.isWaitingForAI) return;
            clearUploadedFiles();
            appendMessage("system", "File allegati rimossi.");
        });
        if (fileUploader) fileUploader.addEventListener('change', (event) => {
            const files = event.target.files;
            if (!files || files.length === 0) {
                if (appState.uploadedFiles.length === 0) fileListDisplay.textContent = "Nessuno";
                updateInteractiveElementsUI(); updateUserInteractionState(); return;
            }
            if (appState.uploadedFiles.length + files.length > MAX_FILES) {
                appendMessage("error", `Max ${MAX_FILES} file.`); fileUploader.value = null; return;
            }
            const fileReadPromises = []; let invalidFileFound = false;
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (!ALLOWED_MIMETYPES.includes(file.type)) {
                    appendMessage("error", `File non supportato: ${file.name} (${file.type}).`);
                    invalidFileFound = true; continue;
                }
                const reader = new FileReader();
                const promise = new Promise((resolve, reject) => {
                    reader.onload = (e) => {
                        if (!appState.uploadedFiles.find(f => f.name === file.name)) {
                            appState.uploadedFiles.push({ name: file.name, type: file.type, dataUrl: e.target.result });
                        } resolve(); };
                    reader.onerror = (e) => {
                        console.error("Errore lettura file:", file.name, e);
                        appendMessage("error", `Errore lettura file: ${file.name}`); reject(e); };
                    reader.readAsDataURL(file);
                });
                fileReadPromises.push(promise);
            }
            Promise.all(fileReadPromises)
                .then(() => {
                    if (appState.uploadedFiles.length > 0) {
                        fileListDisplay.textContent = appState.uploadedFiles.map(f => f.name).join(' | ');
                    } else if (!invalidFileFound) fileListDisplay.textContent = "Nessuno";
                    updateInteractiveElementsUI(); updateUserInteractionState();
                })
                .catch(() => {
                    if (appState.uploadedFiles.length === 0) clearUploadedFiles();
                    updateInteractiveElementsUI(); updateUserInteractionState();
                });
            fileUploader.value = null;
        });

        if (sendButton) sendButton.addEventListener('click', handleUserInput);
        if (helpButton) helpButton.addEventListener('click', () => {
            userInput.value = 'help'; handleUserInput(); userInput.value = '';
        });
        if (resetButton) resetButton.addEventListener('click', () => { resetConversationState('button action'); });
        if (stopButton) stopButton.addEventListener('click', () => {
            if (appState.isWaitingForAI) { userInput.value = 'stop'; handleUserInput(); userInput.value = ''; }
        });
        if (modeSelector) modeSelector.addEventListener('change', (event) => {
            const selectedMode = event.target.value;
            if (selectedMode && selectedMode !== appState.currentCharacter) {
                userInput.value = `imposta modalit√† ${selectedMode}`; handleUserInput(); userInput.value = '';
            }
        });
        if (userInput) {
            userInput.addEventListener("keydown", handleKeyDown);
            userInput.addEventListener("input", adjustTextareaHeight);
        }
        if (terminalDiv) terminalDiv.addEventListener('click', (event) => {
            if (event.target === terminalDiv || (terminalDiv.contains(event.target) && event.target.tagName !== 'A' && !event.target.closest('.copy-btn') && !event.target.closest('button') && !event.target.closest('select'))) {
                if (window.getSelection().toString() === '' && userInput && !userInput.disabled) {
                   userInput.focus();
                }
            }
        });
        window.addEventListener('resize', adjustTextareaHeight);


        // --- Application Initialization ---
        async function initializeApp() {
            if (terminalDiv) appendMessage("system", `Sessione avviata: ${new Date().toLocaleString('it-IT', { dateStyle: 'short', timeStyle: 'medium' })}`);
            if (fileListDisplay) fileListDisplay.textContent = "Nessuno";

            updateUserInteractionState(); // Initial call to set disabled states
            adjustTextareaHeight();

            if (terminalDiv) appendMessage("system", "Recupero configurazione iniziale...");
            try {
                await callWorkerApi({ type: 'init' }); // No signal needed for init
                const defaultModeText = appState.currentCharacter ? appState.currentCharacter.replace(/-/g, ' ') : 'Non impostata';
                if (terminalDiv) appendMessage("system", `Assistente pronto. Modalit√†: ${defaultModeText}. Digita un messaggio, ‚ùì Aiuto, o seleziona modalit√†.`);
            } catch (error) {
                const errorMsg = (error.data && error.data.error) ? error.data.error : (error.message || "Errore sconosciuto.");
                if (terminalDiv) appendMessage("error", `Inizializzazione fallita: ${errorMsg}`);
                if (terminalDiv) appendMessage("system", "Impossibile caricare config. Funzionalit√† limitate. Ricarica pagina.");
                if (userInput) userInput.placeholder = "Inizializzazione fallita. Ricarica.";
                appState.isWaitingForAI = true; // Prevent further interaction
            } finally {
                if (userInput && userInput.placeholder !== "Inizializzazione fallita. Ricarica.") {
                    appState.isWaitingForAI = false;
                }
                updateTokenCounterUI();
                updateUserInteractionState();
                if (userInput && !appState.isWaitingForAI) {
                    setTimeout(() => userInput.focus(), 0);
                }
                scrollToBottom();
            }
        }

        // --- Entry Point: DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => {
            // Check if already authenticated in this session
            if (sessionStorage.getItem(AUTH_SESSION_KEY) === 'true') {
                showMainAppUI();
                initializeApp(); // Initialize if already authenticated
            } else {
                showPasswordScreenUI(); // Show password screen first
            }

            // Setup listeners for password screen
            if (passwordSubmitButton) {
                passwordSubmitButton.addEventListener('click', attemptAuthentication);
            }
            if (passwordInput) {
                passwordInput.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        attemptAuthentication();
                    }
                });
            }
        });
    </script>
</body>
</html>
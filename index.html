<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Assistente ConcordatoFacile</title>
	<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='10 0 100 100'><text y='.9em' font-size='90'>🤖</text></svg>">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        :root {
          /* Core Palette - Soft, Off-White/Grey Base, Refined Accents */
          --bg-color: #f4f7f9; /* Soft, slightly cool off-white */
          --text-color: #2d3748; /* Dark grey-blue, better contrast, less harsh than black */
          --input-bg-color: #ffffff; /* Clean white for input area */
          --border-color: #e2e8f0; /* Lighter, less prominent border */
          --subtle-bg-color: #edf2f7; /* Very light grey for subtle backgrounds */

          /* Accent & Role Colors - Desaturated, Modern Tones */
          --user-prefix-color: #2b6cb0; /* Refined, slightly desaturated blue */
          --assistant-color: #2f855a; /* Calmer, sophisticated green/teal */
          --system-color: #4a5568; /* Medium grey for system messages */
          --command-color: var(--user-prefix-color); /* Link command help to user color */
          --error-color: #c53030; /* Less vibrant, but clear red */
          --highlight-color: var(--user-prefix-color); /* Use user blue for primary highlights */
          --placeholder-color: #a0aec0; /* Softer placeholder text */

          /* UI Elements */
          --scrollbar-thumb-color: #cbd5e0;
          --scrollbar-track-color: #edf2f7;
          --copy-button-bg: rgba(0, 0, 0, 0.03);
          --copy-button-hover-bg: rgba(0, 0, 0, 0.06);

          /* Typography & Spacing - More breathable, modern feel */
          --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
          --font-size-base: 16px; /* Slightly smaller for crispness */
          --font-size-mobile: 15px;
          --line-height: 1.65; /* Increased for better readability */

          --padding-base: 20px; /* Increased spacing */
          --padding-mobile: 15px;
          --border-radius-base: 12px; /* Softer corners */
          --border-radius-small: 6px;
        }

        *, *::before, *::after {
          box-sizing: border-box;
        }

        html {
          font-size: var(--font-size-base);
          -webkit-font-smoothing: antialiased; /* Smoother fonts on MacOS/iOS */
          -moz-osx-font-smoothing: grayscale; /* Smoother fonts on Firefox */
        }

        body {
          background-color: var(--bg-color);
          color: var(--text-color);
          font-family: var(--font-family);
          margin: 0;
          padding: 0;
          display: flex;
          flex-direction: column;
          height: 100vh;
          height: 100dvh; /* Use dvh for better mobile viewport handling */
          overflow: hidden;
        }

        main#terminal {
          flex-grow: 1;
		  padding: var(--padding-base) var(--padding-base) 90px var(--padding-base); /* Increased bottom padding */
          overflow-y: auto;
          white-space: pre-wrap;
          word-wrap: break-word;
          line-height: var(--line-height);
        }

        /* Custom Scrollbar Styling */
        main#terminal::-webkit-scrollbar { width: 10px; }
        main#terminal::-webkit-scrollbar-track { background: var(--scrollbar-track-color); border-radius: 5px;}
        main#terminal::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb-color); border-radius: 5px; border: 2px solid var(--scrollbar-track-color); }
        main#terminal::-webkit-scrollbar-thumb:hover { background-color: #a0aec0; } /* Slightly darker on hover */
        main#terminal { scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb-color) var(--scrollbar-track-color); }

        footer#inputArea {
          display: flex;
          align-items: stretch;
          background-color: var(--input-bg-color);
          padding: calc(var(--padding-base) / 2) var(--padding-base); /* Adjusted padding */
          border-top: 1px solid var(--border-color);
          box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.05); /* Softer, more modern shadow */
          flex-shrink: 0;
          position: relative;
          z-index: 10;
          transition: height 0.1s ease-out; /* Smooth height transition */
        }

        /* Floating Elements */
        .floatingElement {
            position: fixed;
            background-color: rgba(255, 255, 255, 0.85);
            color: var(--text-color);
            padding: 7px 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-base);
            z-index: 1000;
            font-family: var(--font-family);
            font-size: 13px; /* Slightly smaller */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.07);
            transition: bottom 0.2s ease-out, opacity 0.2s ease-out;
            opacity: 0.9;
        }
        .floatingElement:hover {
            opacity: 1;
        }

        #tokenCounter {
            bottom: 90px; /* Adjust based on input area padding */
            right: var(--padding-base);
        }
        #scrollToggle {
            bottom: 90px;
            left: var(--padding-base);
            cursor: pointer;
            user-select: none;
        }


        /* Message Styling */
        .message {
          position: relative;
		  margin-bottom: calc(var(--padding-base) * 0.75); /* Consistent spacing */
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          padding: calc(var(--padding-base) / 1.5); /* Consistent padding */
          border-radius: var(--border-radius-base);
          max-width: 90%; /* Slightly narrower for cleaner look */
          transition: background-color 0.2s ease; /* Subtle hover effect (optional) */
        }
        /* Add subtle hover effect for interaction cue */
        /* .message:hover { background-color: rgba(0,0,0,0.015); } */

        .prefix {
          font-weight: 600; /* Semibold */
          flex-shrink: 0;
          margin-bottom: 0.4em;
          user-select: none;
          white-space: pre;
          font-size: 0.85em; /* Slightly smaller prefix */
          opacity: 0.85; /* Slightly less prominent */
          text-transform: uppercase; /* Standardize prefix casing */
        }

        .content {
          flex-grow: 1;
          word-break: break-word;
          /* color is inherited from body by default, roles can override if needed */
        }

        /* Role-specific styling */
        .user .prefix { color: var(--user-prefix-color); }
        /* .user .content { color: #1a202c; } */ /* Use default dark text or specify if needed */
        .user { background-color: rgba(43, 108, 176, 0.08); align-self: flex-end; } /* Slightly tinted background */

        .assistant .prefix { color: var(--assistant-color); }
        /* .assistant .content { color: #1a202c; } */
        .assistant { background-color: rgba(47, 133, 90, 0.07); align-self: flex-start; }

        .system .prefix { color: var(--system-color); }
        .system .content { color: var(--system-color); }
        .system { background-color: var(--subtle-bg-color); font-size: 0.95em; align-self: center; max-width: 85%; text-align: center; } /* Subtle grey background */

        /* Specific System message types */
        .system.help-output {
            text-align: left;
            align-self: flex-start;
            max-width: 90%;
            background-color: var(--subtle-bg-color);
        }
        .system.help-output .prefix,
        .system.help-output .content {
            color: var(--system-color); /* Keep system color for consistency */
            opacity: 1;
        }
		.system.help-output .content b { /* Style bolded headers */
            color: var(--text-color);
            font-weight: 600;
        }
        .system.help-output .content a { /* Link Styling */
			color: var(--highlight-color); /* Use highlight color for links */
			text-decoration: none;
            font-weight: 500;
		}
        .system.help-output .content a:hover {
            text-decoration: underline;
        }
		.system.help-output code { /* Code Block Styling */
			background-color: rgba(0, 0, 0, 0.04);
            color: var(--text-color);
			padding: 3px 6px;
			border-radius: var(--border-radius-small);
			font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
			font-size: 0.9em;
            border: 1px solid var(--border-color);
            display: inline-block; /* Prevents wrapping issues sometimes */
		}

        .error .prefix { color: var(--error-color); }
        .error .content { color: var(--error-color); font-weight: 500; } /* Slightly less bold */
        .error { background-color: rgba(197, 48, 48, 0.08); align-self: center; text-align: center; max-width: 85%; }

        /* Input Area Elements */
        #prompt {
          color: var(--highlight-color);
          margin-right: 0.7em;
          font-weight: 600; /* Semibold prompt */
          line-height: var(--line-height);
          padding: calc(var(--padding-base) / 2.5) 0; /* Match textarea padding */
          user-select: none;
          align-self: flex-start;
          padding-top: 9px; /* Fine-tune vertical alignment */
        }

        #userInput {
          flex-grow: 1;
          background-color: transparent; /* Inherit from footer */
          border: none;
          outline: none;
          color: var(--text-color);
          font-family: var(--font-family);
          font-size: inherit;
          line-height: var(--line-height);
          padding: calc(var(--padding-base) / 2.5) 0; /* Vertical padding */
          caret-color: var(--highlight-color);
          resize: none;
          overflow-y: hidden; /* Managed by adjustTextareaHeight */
          min-height: calc(var(--line-height) * 1em + (var(--padding-base) / 2.5) * 2 + 2px); /* Calculate min-height accurately */
        }
        #userInput::placeholder { color: var(--placeholder-color); font-style: italic; opacity: 0.9; }
        #userInput:disabled { cursor: not-allowed; opacity: 0.6; }

        /* Loading/Thinking Indicator */
        .loading-content {
            display: inline-flex;
            align-items: baseline;
            opacity: 0.9;
        }
        .thinking-timer-span {
            margin-left: 10px; /* More space */
            font-size: 0.85em;
            opacity: 0.8;
            color: var(--system-color); /* Use system color */
            white-space: nowrap;
        }

        /* Copy Button */
        .copy-btn {
		  position: absolute;
		  top: 8px; /* Adjust position */
		  right: 8px;
		  border: none;
		  background: var(--copy-button-bg);
		  color: var(--highlight-color); /* Match prompt/highlight */
          padding: 4px 8px; /* Slightly larger */
          border-radius: var(--border-radius-small);
		  font-family: var(--font-family);
		  font-size: 0.75em; /* Small but readable */
		  cursor: pointer;
		  opacity: 0; /* Hidden by default */
		  user-select: none;
		  transition: opacity 0.15s ease-in, background-color 0.15s ease-in;
          line-height: 1.2;
          text-align: center;
          font-weight: 500;
		}
		.message:hover .copy-btn { opacity: 0.7; } /* Show on message hover */
        .copy-btn:hover { opacity: 1; background: var(--copy-button-hover-bg); }
		.copy-btn:focus { outline: none; box-shadow: 0 0 0 2px rgba(var(--highlight-color), 0.3); } /* Subtle focus ring */

        /* Responsive Adjustments */
        @media (max-width: 768px) { /* Wider breakpoint for tablets */
          html { font-size: var(--font-size-mobile); }
		  main#terminal {
            padding: var(--padding-mobile) var(--padding-mobile) 80px var(--padding-mobile); /* Adjust padding */
          }
          footer#inputArea { padding: calc(var(--padding-mobile) / 1.5) var(--padding-mobile); }
          #prompt { padding: calc(var(--padding-mobile) / 2.2) 0; padding-top: 8px; margin-right: 0.5em; }
          #userInput { padding: calc(var(--padding-mobile) / 2.2) 0; min-height: calc(var(--line-height) * 1em + var(--padding-mobile)); }

          .message { margin-bottom: calc(var(--padding-mobile) * 1.1); max-width: 95%; }
          .message.user, .message.assistant, .message.system, .message.error { padding: calc(var(--padding-mobile) * 0.9); }
          .system, .error { max-width: 92%; }

          main#terminal::-webkit-scrollbar { width: 8px; }
          main#terminal::-webkit-scrollbar-thumb { border-width: 1.5px; }

          .floatingElement {
              padding: 6px 12px;
              font-size: 12px;
              border-radius: var(--border-radius-base) * 0.8;
          }
          #tokenCounter { bottom: 80px; right: var(--padding-mobile); }
          #scrollToggle { bottom: 80px; left: var(--padding-mobile); }

          .copy-btn { top: 6px; right: 6px; padding: 3px 6px; font-size: 0.7em;}
        }

        /* Small mobile tweaks */
         @media (max-width: 480px) {
            /* Maybe hide scroll toggle on very small screens if needed */
            /* #scrollToggle { display: none; } */
         }

    </style>
</head>
<body>
    <!-- HTML Structure remains unchanged -->
    <main id="terminal"></main>
    <div id="tokenCounter" class="floatingElement">Token: 0</div>
	<div id="scrollToggle" class="floatingElement">🔽 Scroll Automatico: ON</div>
    <footer id="inputArea">
        <span id="prompt">></span>
        <textarea id="userInput" rows="1" placeholder="Inizializzazione..." autofocus autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" disabled></textarea>
    </footer>

    <script>
        // JAVASCRIPT REMAINS IDENTICAL - NO CHANGES BELOW THIS LINE
        const WORKER_URL = "https://germabyte-assistente-80.deno.dev/";

		const COMMAND_INFO = [
		  { name: "help", desc: "help - Mostra questo messaggio di aiuto." },
		  { name: "reset", desc: "reset - Reimposta il contesto della chat." },
		  { name: "imposta modalità", desc: "imposta modalità <nome> - Cambia la modalità AI (reimposta contesto)." },
		  { name: "stop", desc: "stop - Interrompe la risposta corrente dell'AI." }
		];

        const terminalDiv = document.getElementById("terminal");
        const userInput = document.getElementById("userInput");
        const tokenCounterDiv = document.getElementById("tokenCounter");
        const scrollToggleDiv = document.getElementById("scrollToggle");

		let autoScrollEnabled = true;
		// Attach floatingElement class dynamically or ensure it's on the HTML
        scrollToggleDiv.classList.add('floatingElement');
        tokenCounterDiv.classList.add('floatingElement');

		scrollToggleDiv.addEventListener("click", () => {
		  autoScrollEnabled = !autoScrollEnabled;
		  scrollToggleDiv.textContent = autoScrollEnabled
			? "🔽 Scroll Automatico: ON"
			: "⏸️ Scroll Automatico: OFF";
		});

        const promptSpan = document.getElementById("prompt");

        const appState = {
            conversation: [],
            commandHistory: [],
            historyIndex: -1,
            isWaitingForAI: false,
            currentCharacter: null,
            currentModel: null,
            availableCharacters: [],
            currentTokenCount: 0,
            currentTokenLimit: null,
            thinkingIntervalId: null,
            timerIntervalId: null,
            thinkingStartTime: null,
            abortController: null,
            loadingMsgDiv: null,
        };

        function formatTokenCount(num) {
            if (num === undefined || num === null) return '?';
            if (num < 1000) return num.toString();
            return (num / 1000).toFixed(1).replace(/\.0$/, '') + "k";
        }

        function appendMessage(role, text, isLoading = false, extraClass = null, overridePrefix = null) {
            const msgDiv = document.createElement("div");
            msgDiv.classList.add("message", role);

            if (extraClass) {
                msgDiv.classList.add(extraClass);
            }

            const prefixSpan = document.createElement("span");
            prefixSpan.classList.add("prefix");

            const contentSpan = document.createElement("span");
            contentSpan.classList.add("content");

            switch(role) {
                case 'user':
                    prefixSpan.textContent = "UTENTE:"; // Keep JS logic same
                    contentSpan.textContent = text;
                    break;
                case 'assistant':
                    prefixSpan.textContent = overridePrefix ?? `${(appState.currentCharacter || 'AI').toUpperCase()}:`;
                    if (isLoading) {
                        contentSpan.classList.add("loading-content");
                        // Inner structure might need minor tweaks if CSS relies heavily on it, but try to keep JS output same.
                        contentSpan.innerHTML = `<span class="thinking-dots-span">Sto pensando.</span><span class="thinking-timer-span">(0.0s)</span>`;
                    } else {
                        contentSpan.textContent = text;
                    }
                    break;
				case 'system':
					prefixSpan.textContent = "SISTEMA:";
					// Check if JS needs modification for innerHTML vs textContent - keep as is
                    extraClass === 'help-output' ? contentSpan.innerHTML = text : contentSpan.textContent = text;
					break;
                case 'error':
                    prefixSpan.textContent = "ERRORE!";
                    contentSpan.textContent = text;
                    break;
                default:
                    prefixSpan.textContent = "???:";
                    contentSpan.textContent = text;
                    break;
            }

			msgDiv.appendChild(prefixSpan);
			msgDiv.appendChild(contentSpan);

			// Copy Button Logic remains unchanged
			const copyBtn = document.createElement("button");
			copyBtn.classList.add("copy-btn");
			copyBtn.setAttribute("title", "Copia questo messaggio");
			copyBtn.textContent = "Copia"; // Keep text same

			copyBtn.addEventListener("click", (e) => {
			  e.stopPropagation();
			  const txt = contentSpan.textContent || ""; // Extract text simply
			  navigator.clipboard.writeText(txt).then(() => {
				copyBtn.textContent = "Copiato!";
				setTimeout(() => (copyBtn.textContent = "Copia"), 1500);
			  }).catch(() => {
				copyBtn.textContent = "Errore";
				setTimeout(() => (copyBtn.textContent = "Copia"), 1500);
			  });
			});

			msgDiv.appendChild(copyBtn);

			terminalDiv.appendChild(msgDiv);
			scrollToBottom();
			return msgDiv;
		}

		function scrollToBottom() {
		  if (!autoScrollEnabled) return;
		  // Debounce slightly? No, keep simple scroll.
		  requestAnimationFrame(() => {
			terminalDiv.scrollTo({ top: terminalDiv.scrollHeight, behavior: 'smooth' });
		  });
		}

        // Adjust Textarea Height Logic remains unchanged
        function adjustTextareaHeight() {
            userInput.style.height = 'auto';
            let newHeight = userInput.scrollHeight;
            const maxHeight = 180; // Max height stays the same for now
            if (newHeight > maxHeight) {
                newHeight = maxHeight;
                userInput.style.overflowY = 'auto';
            } else {
                userInput.style.overflowY = 'hidden';
            }
            userInput.style.height = newHeight + 'px';

            const inputArea = document.getElementById('inputArea');
            const tokenCounterElem = document.getElementById('tokenCounter');
            const scrollToggleElem = document.getElementById('scrollToggle');


            if (inputArea && tokenCounterElem && scrollToggleElem) {
              // Calculate new bottom position for floating elements based on footer height + buffer
              const inputAreaHeight = inputArea.offsetHeight;
              const buffer = parseInt(window.getComputedStyle(terminalDiv).paddingBottom) / 3 || 15; // Use ~1/3 of terminal bottom padding as buffer
			  const newBottom = `${inputAreaHeight + buffer}px`;

              // Function to update style defensively
              const updateStyle = (elem, styleProp, value) => {
                  if (elem && elem.style[styleProp] !== value) {
                      elem.style[styleProp] = value;
                  }
              };

			  updateStyle(tokenCounterElem, 'bottom', newBottom);
			  updateStyle(scrollToggleElem, 'bottom', newBottom);
            }
        }

        // UI Update Logic remains unchanged
		function updateTokenCounterUI() {
			const countStr = formatTokenCount(appState.currentTokenCount);
			const limitStr = formatTokenCount(appState.currentTokenLimit);
			tokenCounterDiv.textContent = `Token: ${countStr}${appState.currentTokenLimit !== null ? '/' + limitStr : ''}`;
		}

        function updatePromptUI() {
            // Prompt character '>' stays the same
            promptSpan.textContent = "> ";
        }

        function updateUserInteractionState() {
             // State logic remains unchanged
             const isDisabled = userInput.placeholder === "Inizializzazione fallita. Ricarica.";
             userInput.disabled = isDisabled;

             if (appState.isWaitingForAI) {
                 userInput.placeholder = `Digita 'stop' per interrompere`;
             } else if (isDisabled) {
                 // Keep disabled placeholder
             } else if (!appState.currentCharacter) {
                 userInput.placeholder = "Caricamento config...";
             } else {
                 userInput.placeholder = `Chiedi all'IA...`; // Or make more engaging? Keep as is.
             }
             adjustTextareaHeight(); // Ensure height adjusts on state change
        }

        // Animation/Timer Logic remains unchanged
        function startThinkingAnimationAndTimer() {
            if (!appState.loadingMsgDiv) return;

            const dotsSpan = appState.loadingMsgDiv.querySelector('.thinking-dots-span');
            const timerSpan = appState.loadingMsgDiv.querySelector('.thinking-timer-span');
            if (!dotsSpan || !timerSpan) return;

            let dotCount = 1;
            appState.thinkingIntervalId = setInterval(() => {
                dotCount = (dotCount % 3) + 1;
                dotsSpan.textContent = "Sto pensando" + ".".repeat(dotCount);
            }, 400);

            appState.thinkingStartTime = Date.now();
            timerSpan.textContent = `(0.0s)`;
            appState.timerIntervalId = setInterval(() => {
                const elapsedMilliseconds = Date.now() - appState.thinkingStartTime;
                const elapsedSecondsFormatted = (elapsedMilliseconds / 1000).toFixed(1);
                timerSpan.textContent = `(${elapsedSecondsFormatted}s)`;
            }, 100);
        }

        function clearThinkingAnimationAndTimer() {
            if (appState.thinkingIntervalId) {
                clearInterval(appState.thinkingIntervalId);
                appState.thinkingIntervalId = null;
            }
            if (appState.timerIntervalId) {
                clearInterval(appState.timerIntervalId);
                appState.timerIntervalId = null;
            }
            appState.thinkingStartTime = null;
            if (appState.loadingMsgDiv) {
                const contentSpan = appState.loadingMsgDiv.querySelector('.content');
                if (contentSpan) {
                    // Remove helper class added by JS, CSS handles final look
                    contentSpan.classList.remove('loading-content');
                }
            }
        }

        // State/API Interaction Logic remains unchanged
        function updateStateFromWorkerResponse(data) {
            if (data.activeCharacter) appState.currentCharacter = data.activeCharacter;
            if (data.activeModel) appState.currentModel = data.activeModel;
            if (data.availableCharacters) appState.availableCharacters = data.availableCharacters;
            if (typeof data.tokenCount === 'number') appState.currentTokenCount = data.tokenCount;
            if (typeof data.tokenLimit === 'number') appState.currentTokenLimit = data.tokenLimit;

            updateTokenCounterUI();
            updatePromptUI();
        }

        function resetConversationState(reason) {
            const reasonMap = {
                'user command': 'comando utente',
                'character change': 'cambio modalità',
                'token limit': 'limite token',
                'input limit': 'limite input'
            };
            const italianReason = reasonMap[reason] || reason;

            appState.conversation = [];
            appState.currentTokenCount = 0;
            updateTokenCounterUI();
            appendMessage("system", `Contesto chat reimpostato (${italianReason}). Nuova conversazione avviata.`);
            scrollToBottom();
        }

        async function callWorkerApi(payload, signal) {
            let response;
            try {
                response = await fetch(WORKER_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                    signal
                });

                const data = await response.json();

                if (!response.ok) {
                    let errorMsg = `Errore API (${response.status})`;
                    errorMsg += `: ${data?.error || response.statusText}`;
                    if (data?.details) console.error("Dettagli Errore API:", data.details);
                    console.error("Risposta Errore API Completa:", data);

                    if (data?.availableCharacters) appState.availableCharacters = data.availableCharacters;
                    if (typeof data?.tokenLimit === 'number') appState.currentTokenLimit = data.tokenLimit;
                    if (typeof data?.tokenCount === 'number') appState.currentTokenCount = data.tokenCount;
                    updateTokenCounterUI();

                    const error = new Error(errorMsg);
                    error.status = response.status;
                    error.data = data;
                    throw error;
                }

                if (!data || (payload.messages && typeof data.completion !== 'string' && !signal?.aborted)) {
                     console.error("Struttura risposta API inattesa:", data);
                     throw new Error("Ricevuto un formato di risposta inatteso dall'API.");
                }

                updateStateFromWorkerResponse(data);

                return data;

            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log("Fetch interrotto dall'utente.");
                    throw error; // Re-throw to be handled by caller
                }

                console.error("Errore Fetch/API:", error);
                if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                     const networkError = new Error("Errore di rete. Impossibile raggiungere il worker API.");
                     networkError.status = 0; // Assign a pseudo-status for network errors
                     throw networkError;
                }
                // Re-throw other errors
                throw error;
            }
        }

        // Input Handling Logic remains unchanged (including commands)
        async function handleUserInput() {
            const inputText = userInput.value.trim();
            userInput.value = "";
            adjustTextareaHeight();

            if (inputText === "") return;

            // Handle 'stop' command during AI processing
            if (appState.isWaitingForAI) {
                if (inputText.toLowerCase() === 'stop') {
                    appendMessage("user", inputText); // Display user command
                    if (appState.abortController) {
                        appState.abortController.abort(); // Trigger abort
                        // System message added in the catch/finally block of the API call now
                    } else {
                        appendMessage("error", "Impossibile fermare: Nessun processo AI attivo trovato.");
                    }
                } else {
                    appendMessage("user", inputText);
                    appendMessage("system", `Input "${inputText}" ignorato: AI occupata. Digita 'stop' per interrompere.`);
                }
                scrollToBottom();
                return; // Don't process further if waiting
            }

            // Command History update
            if (appState.commandHistory.length === 0 || appState.commandHistory[appState.commandHistory.length - 1] !== inputText) {
                appState.commandHistory.push(inputText);
            }
            appState.historyIndex = appState.commandHistory.length; // Reset index to end

            // Command Parsing (lowercase for command check, original for args if needed)
            const commandArgs = inputText.toLowerCase().split(/\s+/);
            const command = commandArgs[0];
            const originalArgs = inputText.split(/\s+/); // Keep original casing for values like character names

            // --- Command Handling ---
            if (command === 'reset') {
                appendMessage("user", inputText);
                resetConversationState('user command');
                return;
            }

            if (command === 'help') {
                appendMessage("user", inputText);
                // Sorting and formatting remain the same
				const commandsSorted = [...COMMAND_INFO].sort((a, b) =>
					a.name.localeCompare(b.name, undefined, { sensitivity: "base" })
				);

				let helpOutput = "<b>COMANDI DISPONIBILI:</b>\n"; // Slightly better header
				commandsSorted.forEach(c => {
					helpOutput += `  <code>${c.desc}</code>\n`; // Use <code> for clarity
				});
				helpOutput += "\n<b>MODALITÀ DISPONIBILI:</b>\n";
				const chars = [...(appState.availableCharacters || [])].sort((a, b) => a.localeCompare(b));
				helpOutput += `  ${chars.length ? chars.join(', ') : 'Nessuna modalità definita.'}\n\n`; // Use clearer text
				helpOutput += "<b>STATO ATTUALE:</b>\n";
				helpOutput += `  Modalità Attiva: ${appState.currentCharacter || 'N/D'}\n`;
				helpOutput += `  Modello AI:  ${appState.currentModel || 'N/D'}\n\n`;
				helpOutput += `<b>UTILIZZO BASE:</b>\n`;
				helpOutput += "  • Inserisci un messaggio per chattare con l'AI.\n";
                helpOutput += "  • Usa i comandi per gestire la sessione.\n"; // Added clarification
				appendMessage("system", helpOutput, false, "help-output");
				scrollToBottom();
				return;
            }

             if (command === 'imposta' && commandArgs.length > 1 && commandArgs[1] === 'modalità') {
                appendMessage("user", inputText); // Show the full command entered
                if (originalArgs.length < 3) {
                     appendMessage("error", "Utilizzo non corretto. Esempio: imposta modalità <NomeModalità>");
                     return;
                }
                const settingValue = originalArgs.slice(2).join(' '); // Get the character name with original casing

                 // Case-insensitive search but store/use the actual name from availableCharacters
                 const characterNameLower = settingValue.toLowerCase();
                 const foundCharacter = appState.availableCharacters.find(c => c.toLowerCase() === characterNameLower);

                 if (foundCharacter) {
                     if (appState.currentCharacter !== foundCharacter) {
                         // Use the correctly cased name from the list
                         appState.currentCharacter = foundCharacter;
                         appendMessage("system", `Modalità AI cambiata in: ${appState.currentCharacter}.`);
                         // Backend expects 'character', frontend state is also 'currentCharacter'
                         resetConversationState('character change');
                         updatePromptUI(); // Reflect change if prompt depends on character (it doesn't here)
                     } else {
                          appendMessage("system", `La modalità è già impostata su: ${appState.currentCharacter}.`);
                     }
                 } else {
                     const sortedChars = [...(appState.availableCharacters || [])].sort((a, b) => a.localeCompare(b));
                     appendMessage("error", `Modalità "${settingValue}" non trovata. Disponibili: ${sortedChars.join(', ') || 'Nessuna'}`);
                 }
                 scrollToBottom();
                 return;
             } else if (command === 'imposta') {
                  appendMessage("user", inputText);
                  appendMessage("error", "Comando 'imposta' sconosciuto o incompleto. Usa 'imposta modalità <nome>'.");
                  return;
             }

            // --- Default: Send message to AI ---
            appendMessage("user", inputText);
            appState.conversation.push({ role: "user", content: inputText });
            scrollToBottom(); // Scroll after adding user message

            appState.isWaitingForAI = true;
            appState.loadingMsgDiv = appendMessage("assistant", "", true); // Add loading message placeholder
            startThinkingAnimationAndTimer();
            appState.abortController = new AbortController(); // Create new controller for this request
            updateUserInteractionState();

            try {
                const payload = {
                    messages: appState.conversation, // Send current history
                    character: appState.currentCharacter, // Send selected character
                    model: appState.currentModel // Optionally send model if needed by backend
                };
                const result = await callWorkerApi(payload, appState.abortController.signal);

                // Success path (if not aborted)
                clearThinkingAnimationAndTimer();

                if (appState.loadingMsgDiv && !appState.abortController.signal.aborted) {
                     const contentSpan = appState.loadingMsgDiv.querySelector('.content');
                     const prefixSpan = appState.loadingMsgDiv.querySelector('.prefix');
                     if (contentSpan && prefixSpan) {
                         // Update existing placeholder div content
                         contentSpan.classList.remove('loading-content'); // Managed by clearThinking... but ensure it's removed
                         prefixSpan.textContent = `${(appState.currentCharacter || 'AI').toUpperCase()}:`; // Update prefix just in case character changed mid-flight (unlikely)
                         contentSpan.textContent = result.completion; // Set final text
                         // Re-attach copy button logic to the now-filled message if necessary
                         // The current implementation adds it on creation, which should be fine.
                     } else {
                         // Fallback if placeholder elements not found
                         if (appState.loadingMsgDiv) appState.loadingMsgDiv.remove(); // Remove broken placeholder
                         appendMessage("assistant", result.completion); // Append as new message
                     }
                     appState.loadingMsgDiv = null; // Clear reference once filled/removed
                }

                // Add successful completion to conversation history if not aborted
                if (result.completion !== undefined && !appState.abortController.signal.aborted) {
                    appState.conversation.push({ role: "assistant", content: result.completion });
                    updateTokenCounterUI(); // Update tokens after successful response
                }

                 // Check token limit *after* receiving response and updating count
                 if (appState.currentTokenLimit !== null && appState.currentTokenCount >= appState.currentTokenLimit) {
                     appendMessage("system", `Limite token (${formatTokenCount(appState.currentTokenLimit)}) raggiunto. Reimpostazione automatica del contesto.`);
                     resetConversationState('token limit');
                 }

            } catch (error) {
                clearThinkingAnimationAndTimer();

                if (appState.loadingMsgDiv) {
                    appState.loadingMsgDiv.remove(); // Clean up placeholder on error too
                    appState.loadingMsgDiv = null;
                }

                if (error.name === 'AbortError') {
                    // Specific message for user-initiated stop
                    appendMessage("system", "Richiesta AI interrotta dall'utente.");
                    // Don't add to conversation history
                    // State already handled by 'stop' command logic + finally block
                } else {
                    // Handle API errors or network errors
                    appendMessage("error", error.message || "Si è verificato un errore sconosciuto.");
                    scrollToBottom(); // Scroll to show error

                    // Check for specific error conditions requiring context reset
                    if (error.status === 413 || (error.data && error.data.error_code === 'CONTEXT_LENGTH_EXCEEDED')) {
                         appendMessage("system", "Messaggio troppo lungo o limite contesto superato. Reimpostazione automatica del contesto.");
                         resetConversationState('input limit');
                    }

                    // Optionally remove the failed user message from history if desired? No, keep it.
                    // appState.conversation.pop();

                     if (userInput.placeholder !== "Inizializzazione fallita. Ricarica.") {
                       userInput.placeholder = `Errore. Riprova o usa 'reset'.`; // Simplified error placeholder
                     }
                }

            } finally {
                // This block runs after success, handled errors, or aborts
                clearThinkingAnimationAndTimer(); // Ensure timers are always cleared
                appState.isWaitingForAI = false;
                appState.abortController = null; // Clean up controller reference

                if (appState.loadingMsgDiv) { // Ensure placeholder is removed if still referenced somehow
                    appState.loadingMsgDiv.remove();
                    appState.loadingMsgDiv = null;
                }

                if (userInput.placeholder !== "Inizializzazione fallita. Ricarica.") {
                   updateUserInteractionState(); // Reset placeholder/disabled state
                   // Ensure focus returns to input after processing, slight delay helps.
                   // Only focus if user hasn't clicked elsewhere. Check activeElement? Simpler to just focus.
                   setTimeout(() => userInput.focus(), 50);
                }

                 adjustTextareaHeight(); // Final height adjustment
                 scrollToBottom(); // Ensure latest message/error is visible
            }
        }

        // Keyboard Input Handling Logic remains unchanged
        function handleKeyDown(event) {
            // Enter key sends message (if not Shift+Enter)
            if (event.key === "Enter" && !event.shiftKey && !userInput.disabled) {
                event.preventDefault(); // Prevent newline in textarea
                handleUserInput();
            }
            // Arrow keys for command history navigation
            else if (event.key === "ArrowUp" && !userInput.disabled && userInput.selectionStart === 0 && userInput.selectionEnd === 0) { // Only when cursor at start
                if (appState.commandHistory.length > 0 && appState.historyIndex > 0) {
                    event.preventDefault();
                    appState.historyIndex--;
                    userInput.value = appState.commandHistory[appState.historyIndex];
                    // Move cursor to end after setting value
                    requestAnimationFrame(() => {
                      userInput.setSelectionRange(userInput.value.length, userInput.value.length);
                    });
                    adjustTextareaHeight();
                }
            }
            else if (event.key === "ArrowDown" && !userInput.disabled && userInput.selectionStart === userInput.value.length && userInput.selectionEnd === userInput.value.length) { // Only when cursor at end
                 if (appState.historyIndex < appState.commandHistory.length - 1) {
                    event.preventDefault();
                    appState.historyIndex++;
                    userInput.value = appState.commandHistory[appState.historyIndex];
                     requestAnimationFrame(() => {
                       userInput.setSelectionRange(userInput.value.length, userInput.value.length);
                     });
                    adjustTextareaHeight();
                } else if (appState.historyIndex === appState.commandHistory.length - 1) {
                    // If at the last history item, pressing down again clears input
                    event.preventDefault();
                    appState.historyIndex++; // Move past the end
                    userInput.value = "";
                    adjustTextareaHeight();
                }
            }
        }

        // Initialization Logic remains unchanged
        async function initializeApp() {
            appendMessage("system", `Sessione avviata: ${new Date().toLocaleString('it-IT')}`);

            updateTokenCounterUI(); // Initialize counter UI
            updatePromptUI();       // Initialize prompt UI
            userInput.placeholder = "Inizializzazione...";
            userInput.disabled = true;
            adjustTextareaHeight(); // Adjust initial height
            scrollToBottom();

            appendMessage("system", "Recupero configurazione iniziale...");
            try {
                // Call worker's init endpoint
                await callWorkerApi({ type: 'init' }); // No signal needed for init

                // Assuming updateStateFromWorkerResponse correctly populates appState
                appendMessage("system", `Configurazione caricata.`);
                appendMessage("system", `Modalità: ${appState.currentCharacter}. Modello: ${appState.currentModel}. Limite Token: ${formatTokenCount(appState.currentTokenLimit) || 'N/D'}.`);
                appendMessage("system", `Pronto. Digita 'help' per i comandi.`);

                // Enable input
                userInput.disabled = false;
                appState.isWaitingForAI = false; // Not waiting initially
                updateUserInteractionState(); // Set correct placeholder like "Chiedi all'IA..."
                setTimeout(() => userInput.focus(), 100); // Delay focus slightly

            } catch (error) {
                appendMessage("error", `Inizializzazione fallita: ${error.message}`);
                appendMessage("system", "Impossibile caricare la configurazione. Ricarica la pagina per riprovare.");
                // Keep input disabled, set permanent error placeholder
                userInput.placeholder = "Inizializzazione fallita. Ricarica.";
                userInput.disabled = true;
                appState.isWaitingForAI = true; // Effectively lock state
            } finally {
                 scrollToBottom(); // Scroll after final init messages
                 adjustTextareaHeight(); // Adjust height after all content added
            }
        }

        // Event Listeners Setup remains unchanged
        userInput.addEventListener("keydown", handleKeyDown);
        userInput.addEventListener("input", adjustTextareaHeight); // Adjust height dynamically on input

        // Refocus input on terminal click (if not selecting text or clicking links/buttons)
        terminalDiv.addEventListener('click', (event) => {
            // Check if click is on terminal background, not on text, link, or button
            if (event.target === terminalDiv || (terminalDiv.contains(event.target) && event.target.tagName !== 'A' && !event.target.closest('.copy-btn') && window.getSelection().toString() === ''))
             {
                // Only focus if input is enabled and AI is not busy
                if (!appState.isWaitingForAI && !userInput.disabled) {
                   userInput.focus();
                }
            }
        });

        // Adjust height on window resize
        window.addEventListener('resize', adjustTextareaHeight);

        // Start the application
        initializeApp();

    </script>
</body>
</html>